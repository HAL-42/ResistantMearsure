C51 COMPILER V9.01   MENU                                                                  07/22/2018 14:28:58 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MENU
OBJECT MODULE PLACED IN .\Menu.obj
COMPILER INVOKED BY: D:\Kell\C51\BIN\C51.EXE ..\Src\Menu.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Menu.lst) OBJECT(.\Menu.obj
                    -)

line level    source

   1          #include "RM.h"
   2          #include "Menu.h"
   3          #include "Timer.h"
   4          #include "Key.h"
   5          #include "LCD1602.h"
   6          #include "CalcR.h"
   7          
   8          #define MENUID_DEBUG_MODE_ON    0                                       //ËèúÂçïÈÄâÈ°πIDÁöÑÂÆèÂÆö‰πâ
   9          #define MENUID_SIEVE_MODE_ON    1
  10          #define MENUID_SET_SIEVE        3
  11          #define MENUID_START_PLOT       4
  12          #define MENUID_RESET_DEVICE     5
  13          #define MENUID_EXIT             6
  14          #define MENUID_DEBUG_YES                7
  15          #define MENUID_DEBUG_NO                 8
  16          #define MENUID_SIEVE_YES        9               
  17          #define MENUID_SIEVE_NO                 10      
  18          #define MENUID_AVERGE_YES       11
  19          #define MENUID_AVERGE_NO                12
  20          #define MENUID_AVERG_MODE_ON    13      
  21          
  22          #define MENU_OPTION_NUM_MAIN    7                                       //ËèúÂçïÊù°ÁõÆÊï∞ÁöÑÂÆèÂÆö‰πâ
  23          #define MENU_OPTION_NUM_YN              2
  24          
  25          typedef struct MenuRecord *ptrToMenuRecord;                     //ÂÆö‰πâÊåáÂêëËèúÂçïËÆ∞ÂΩïÁöÑÊåáÈíà
  26          typedef ptrToMenuRecord   Menu;                                         //ÊåáÂêëËèúÂçïËÆ∞ÂΩïÁöÑÊåáÈíàÁõ¥Êé•Âè´Menu
  27          typedef struct MenuOp     *ptrToMenuOp;                         //ÊåáÂêëËèúÂçïÈÄâÈ°πÁöÑÊåáÈíà
  28          
  29          struct MenuOp{                                                                          //ËèúÂçïÈÄâÈ°πÁöÑÁªìÊûÑ
  30                  uchar opID;                                                                             //ÈÄâÈ°πÁöÑID
  31                  char *opString;                                                                 //ÈÄâÈ°πÊòæÁ§∫ÁöÑÂ≠óÁ¨¶‰∏≤
  32                  Menu subMenu;                                                                   //ÈÄâÈ°πÁöÑÂ≠êËèúÂçï
  33                  void (*pOpFunc) (void);                                                 //ÈÄâÊã©ËØ•ÈÄâÈ°πÊâßË°åÁöÑÂáΩÊï∞
  34          };
  35          
  36          struct MenuRecord{                                                                      //ËèúÂçïËÆ∞ÂΩïÁöÑÁªìÊûÑ
  37                  uchar opNum;                                                                    //ËØ•ËèúÂçïÈÄâÈ°πÁöÑÊù°ÁõÆÊï∞
  38                  Menu superMenu;                                                                 //ËØ•ËèúÂçïÁöÑ‰∏ä‰∏ÄÁ∫ßËèúÂçï
  39                  ptrToMenuOp OpArray;                                                    //ËØ•ËèúÂçïÁöÑÊù°ÁõÆÊï∞ÁªÑ
  40          };
  41          
  42          static code struct MenuOp debugYNOpArray[MENU_OPTION_NUM_YN]={                                                          //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  43                  {MENUID_DEBUG_YES,"Yes",NULL,MenuOpYN},
  44                  {MENUID_DEBUG_NO,"No",NULL,MenuOpYN}
  45          };
  46          static struct MenuRecord debugYNMenuRecord={MENU_OPTION_NUM_YN,NULL,debugYNOpArray};            //Yes No  ËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  47          static code Menu debugYNMenu=&debugYNMenuRecord;                                                                                        //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  48          
  49          static code struct MenuOp sieveYNOpArray[MENU_OPTION_NUM_YN]={                                                          //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  50                  {MENUID_SIEVE_YES,"Yes",NULL,MenuOpYN},
  51                  {MENUID_SIEVE_NO,"No",NULL,MenuOpYN}
  52          };
  53          static struct MenuRecord sieveYNMenuRecord={MENU_OPTION_NUM_YN,NULL,sieveYNOpArray};            //Yes No  ËèúÂçïÁöÑË
C51 COMPILER V9.01   MENU                                                                  07/22/2018 14:28:58 PAGE 2   

             -èúÂçïËÆ∞ÂΩï
  54          static code Menu sieveYNMenu=&sieveYNMenuRecord;                                                                                        //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  55          
  56          static code struct MenuOp avergYNOpArray[MENU_OPTION_NUM_YN]={                                                          //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  57                  {MENUID_AVERGE_YES,"Yes",NULL,MenuOpYN},
  58                  {MENUID_AVERGE_NO,"No",NULL,MenuOpYN}
  59          };
  60          static struct MenuRecord avergYNMenuRecord={MENU_OPTION_NUM_YN,NULL,avergYNOpArray};            //Yes No  ËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  61          static code Menu avergYNMenu=&avergYNMenuRecord;                                                                                        //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  62          
  63          static code struct MenuOp MainMenuOpArray[MENU_OPTION_NUM_MAIN]={                                                       //mainËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ                             
  64                  {MENUID_DEBUG_MODE_ON,"Debug Mode On",&debugYNMenuRecord,NULL},
  65                  {MENUID_AVERG_MODE_ON,"Averg Mode On",&avergYNMenuRecord,NULL},
  66                  {MENUID_SIEVE_MODE_ON,"Sieve Mode On",&sieveYNMenuRecord,NULL},
  67                  {MENUID_SET_SIEVE,"Set Sieve",NULL,MenuOpSetSieve},
  68                  {MENUID_START_PLOT,"Start Plot",NULL,MenuOpStartPlot},
  69                  {MENUID_RESET_DEVICE,"Reset Device",NULL,MenuOpRstDev},
  70                  {MENUID_EXIT,"Exit",NULL,MenuOpExit}
  71          };
  72          static code struct MenuRecord mainMenuRecord={MENU_OPTION_NUM_MAIN,NULL,MainMenuOpArray};       //mainËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  73          static code Menu mainMenu=&mainMenuRecord;                                                                                                  //Áî®Âè´ÂÅömainMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  74          
  75          static Menu  curMenu;                                                           //ÊåáÂêëÂΩìÂâçËèúÂçïÁöÑËÆ∞ÂΩï
  76          static char curOp;                                                                      //ÂΩìÂâçÊù°ÁõÆ
  77          
  78          static bit isExit;                                                                      //Ê∂àÊÅØÂèòÈáèÔºöÊòØÂê¶ÈÄÄÂá∫ËèúÂçï
  79          
  80          extern bit   isSieveOn;                                                         //Ê∂àÊÅØÂèòÈáè:Á≠õÈÄâÊòØÂê¶ÊâìÂºÄ
  81          extern float sieveRVal;                                                         //Á≠õÈÄâÁîµÈòªÁöÑ‰∏≠ÂøÉÂÄº
  82          extern float errTolr;                                                           //ËØØÂ∑ÆÈôê
  83          extern bit   isDebug;                                                           //Ê∂àÊÅØÂèòÈáè:Ë∞ÉËØïÊ®°ÂºèÊâìÂºÄ
  84          extern bit   isAverg;
  85          
  86          sbit    Led1 = P1^0;                                                            //LedÂèòÈáè
  87          sbit    Led2 = P1^1;
  88          sbit    Led3 = P1^2;
  89          
  90          sbit servoConOut = P3^7;
  91          
  92          static uchar pwmTCount;                         
  93          static uchar pwmNCount;                         
  94          static xdata float pwmRVal[17]; 
  95          
  96          sbit  capSel=P3^7;
  97          extern float idata curRValue;
  98          extern code char *mearsStr;
  99          code char *disconnectStr="Disconnect P37";
 100          code char *connectStr="Connect P37";
 101          
 102          extern uchar t1IntrTimes;               
 103          extern bit isKeyEvents;
 104          extern bit isTimerEvent;
 105          
 106          extern uchar key1Events;
 107          extern uchar key2Events;
 108          extern uchar key3Events;
 109          
 110          static uint  rNumPart;                                                          //Á≠õÈÄâÁîµÈòªÁöÑ‰∏â‰ΩçÊï∞Â≠óÈÉ®ÂàÜ
 111          static uchar rUnit;                                                                     //Á≠õÈÄâÁîµÈòªÁöÑÂçï‰ΩçÔºåÂèØ‰ª•ÊòØ 0x20 'K' 'M'
 112          static uchar errTolrE2;                                                         //ËØØÂ∑ÆÈôê*100
C51 COMPILER V9.01   MENU                                                                  07/22/2018 14:28:58 PAGE 3   

 113          /**
 114           * ÂàùÂßãÂåñËèúÂçï
 115           * @Author   Xiaobo     Yang
 116           * @DateTime 2018-07-21
 117           * @Summury
 118           */
 119          void InitialMenu(){
 120   1              debugYNMenu->superMenu=mainMenu;                                //ËèúÂçïÂâçÂêé‰∫íÊåáÔºåÂõ†Ê≠§‰∏ÄÈÉ®ÂàÜÊåáÂêëÂ∑•‰ΩúË¶ÅÂà∞Á®ãÂ∫èÂÆåÊàê
 121   1              sieveYNMenu->superMenu=mainMenu;
 122   1              avergYNMenu->superMenu=mainMenu;
 123   1              curMenu=mainMenu;                                                               //ÂàùÂßãÂåñÊâÄÊúâÊúâÂÖ≥ÂÖ®Â±ÄÂèòÈáè
 124   1              curOp=0;
 125   1              isExit=0;
 126   1              isSieveOn=0;
 127   1              sieveRVal=0.0;
 128   1              errTolr=0.0;
 129   1              rNumPart=0;
 130   1              rUnit=0x20;
 131   1              errTolrE2=0;
 132   1              isDebug=1;
 133   1              pwmTCount=0;
 134   1              pwmNCount=0;
 135   1      }
 136          /**
 137           * ÊâìÂºÄËèúÂçï
 138           * @Author   Xiaobo     Yang
 139           * @DateTime 2018-07-21
 140           * @Summury
 141           */
 142          void MenuImpl(){
 143   1              curMenu=mainMenu;                                                               //‰ªéÂ§¥ÂºÄÂßãÊòæÁ§∫ËèúÂçï
 144   1              curOp=0;
 145   1              isExit=0;
 146   1              ShowMenu();
 147   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);                              //ÂºÄÂßãÈîÆÁõòÊâ´Êèè
 148   1              StartTimer();
 149   1              while(!isExit){
 150   2                      if(isKeyEvents){
 151   3                              SwitchTimerFun(TIMERFUN_HALT);                  //TODO:ÊàñËÆ∏ÂèØ‰ª•‰ºòÂåñÊéâ
 152   3                              MenuKeyTreat();
 153   3                              SwitchTimerFun(TIMERFUN_KEY_SCAN);              //ÈáçÂêØÈîÆÁõòÊâ´Êèè
 154   3                              StartTimer();
 155   3                      }
 156   2              }
 157   1      }
 158          /**
 159           * ÊòæÁ§∫ËèúÂçï
 160           * @Author   Xiaobo     Yang
 161           * @DateTime 2018-07-21
 162           * @Summury
 163           */
 164          void ShowMenu(){
 165   1              LCDCls();
 166   1              if(curOp!=0){
 167   2                      LCDMoveCursor(1,0);                                                                             //Ê≠§Â§ÑÊúâËé´ÂêçÂÖ∂Â¶ôÁöÑbugÔºåÈúÄË¶Å‰∏ìÈó®ÈáçËÆæÂÖâÊ†á
 168   2                      LCDPrintStr(1,0,curMenu->OpArray[curOp-1].opString);
 169   2                      LCDPrintStr(1,1,curMenu->OpArray[curOp].opString);
 170   2                      LCDPrintChar(0,1,'>');
 171   2              }
 172   1              else{
 173   2                      LCDMoveCursor(1,0);
 174   2                      LCDPrintStr(1,0,curMenu->OpArray[curOp].opString);
C51 COMPILER V9.01   MENU                                                                  07/22/2018 14:28:58 PAGE 4   

 175   2                      LCDPrintStr(1,1,curMenu->OpArray[curOp+1].opString);
 176   2                      LCDPrintChar(0,0,'>');
 177   2              }
 178   1      }
 179          /**
 180           * Â§ÑÁêÜËèúÂçïÊ®°Âºè‰∏ãÁöÑÊåâÈîÆ‰ø°ÊÅØ
 181           * @Author   Xiaobo     Yang
 182           * @DateTime 2018-07-21
 183           * @Summury
 184           */
 185          void MenuKeyTreat(){
 186   1              if(key1Events){                                                                                 //key1‰ºòÂÖàÁ∫ß>key2‰ºòÂÖàÁ∫ß>key3‰ºòÂÖàÁ∫ß
 187   2                      switch(key1Events){
 188   3                              case SHORT_PRESS:
 189   3                                      curOp=(++curOp)%(curMenu->opNum);                       //Âêë‰∏ãÈÄâÊã©
 190   3                                      ShowMenu();
 191   3                                      break;
 192   3                              case LONG_PRESS:
 193   3                                      curOp=curMenu->opNum-1;
 194   3                                      ShowMenu();
 195   3                                      break;
 196   3                      }
 197   2              }
 198   1              else if(key2Events){
 199   2                      switch(key2Events){
 200   3                              case SHORT_PRESS:                                                               //Âêë‰∏äÈÄâÊã©
 201   3                                      curOp=((--curOp)<0?curOp+(curMenu->opNum):curOp);       
 202   3                                      ShowMenu();
 203   3                                      break;
 204   3                              case LONG_PRESS:
 205   3                                      curOp=0;
 206   3                                      ShowMenu();
 207   3                                      break;
 208   3                      }
 209   2              }
 210   1              else{
 211   2                      switch(key3Events){
 212   3                              case SHORT_PRESS:
 213   3                              if(curMenu->OpArray[curOp].subMenu!=NULL){
 214   4                                      curMenu=curMenu->OpArray[curOp].subMenu;        //ËøõÂÖ•Â≠êËèúÂçï
 215   4                                      curOp=0;
 216   4                                      ShowMenu();
 217   4                              }
 218   3                              else{
 219   4                                      KeyInitial();                                                           //ÂàùÂßãÂåñÂ§ñËÆæÔºåÊó∂ÈíüÂ∑≤ÁªèÂú®MenuImpl‰∏≠ÂÅúÊ≠¢
 220   4                                      isExit=1;                                                                       //ËÆæÂÆöÈÄÄÂá∫Ê®°Âºè
 221   4                                      (*(curMenu->OpArray[curOp].pOpFunc)) ();        //ÊâßË°åÈÄâÈ°πÁöÑÂáΩÊï∞
 222   4                              }       
 223   3                                      break;
 224   3                              case LONG_PRESS:                                                                //ÈïøÊåâÂèØ‰ª•ÂõûÂà∞‰∏äÁ∫ßËèúÂçï
 225   3                                      if(curMenu->superMenu!=NULL){
 226   4                                              curMenu=curMenu->superMenu;
 227   4                                              curOp=0;
 228   4                                              ShowMenu();
 229   4                                      }
 230   3                                      break;
 231   3                              default:
 232   3                                      break;
 233   3                      }
 234   2              }
 235   1              RstKeyEvents();
 236   1      }
C51 COMPILER V9.01   MENU                                                                  07/22/2018 14:28:58 PAGE 5   

 237          /**
 238           * ‰ªÄ‰πàÈÉΩ‰∏çÂÅö
 239           * @Author   Xiaobo     Yang
 240           * @DateTime 2018-07-21
 241           * @Summury
 242           */
 243          void MenuOpExit(){
 244   1              return;
 245   1      }
 246          /**
 247           * Âà©Áî®IAP_CONTRËøõË°åËΩØ‰ª∂Â§ç‰Ωç
 248           * @Author   Xiaobo     Yang
 249           * @DateTime 2018-07-21
 250           * @Summury
 251           */
 252          void MenuOpRstDev(){
 253   1              uint i=3000;
 254   1              Led3=Led2=Led1=0;                                                                               //ÁÅ≠ÁÅØÔºåÁ≠âÂæÖÊøÄÂä®‰∫∫ÂøÉÁöÑ‰∏ÄÂàª
 255   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);
 256   1              StartTimer();
 257   1              while(i){
 258   2                      if(isTimerEvent){
 259   3                              isTimerEvent=0;
 260   3                              i--;                                                                                    //ÊØè0.5msËÆ©iÂáè‰∏ÄÔºå0.5S‰∫Æ‰∏Ä‰∏™ÁÅØ
 261   3                              if(i==2000){
 262   4                                      Led3=1;
 263   4                              }
 264   3                              else if(i==1000){
 265   4                                      Led2=1;
 266   4                              }
 267   3                      }
 268   2                      if(isKeyEvents){                                                                        //Â¶ÇÊúâÈîÆÁõò‰∫ã‰ª∂ÔºåÁ´ãÂç≥‰∏≠Êñ≠ÂáΩÊï∞ÊâßË°å
 269   3                              Led3=Led2=0;
 270   3                              return;
 271   3                      }
 272   2              }
 273   1              Led1=1;
 274   1              delaynms(500);
 275   1              ISP_CONTR=0x60;                                                                                 //ËΩØ‰ª∂Â§ç‰Ωç
 276   1      }
 277          /**
 278           * YNËèúÂçïÊâßË°åÔºåÁî®‰∫éÊîπÂèòdebugÂíåsieveÊ®°Âºè
 279           * @Author   Xiaobo     Yang
 280           * @DateTime 2018-07-21
 281           * @Summury
 282           */
 283          void MenuOpYN(){
 284   1              switch(curMenu->OpArray[curOp].opID){
 285   2                      case MENUID_DEBUG_YES:
 286   2                              isDebug=1;
 287   2                              break;
 288   2                      case MENUID_DEBUG_NO:
 289   2                              isDebug=0;
 290   2                              break;
 291   2                      case MENUID_SIEVE_YES:
 292   2                              isSieveOn=1;
 293   2                              break;
 294   2                      case MENUID_SIEVE_NO:
 295   2                              isSieveOn=0;
 296   2                              break;
 297   2                      case MENUID_AVERGE_YES:
 298   2                              isAverg=1;
C51 COMPILER V9.01   MENU                                                                  07/22/2018 14:28:58 PAGE 6   

 299   2                              break;
 300   2                      case MENUID_AVERGE_NO:
 301   2                              isAverg=0;
 302   2                              break;
 303   2              }
 304   1      }
 305          /**
 306           * ËΩ¨Âä®ËàµÊú∫ÁîªÊõ≤Á∫ø
 307           * @Author   Xiaobo     Yang
 308           * @DateTime 2018-07-21
 309           * @Summury
 310           */
 311          void MenuOpStartPlot(){
 312   1              uchar curShow;
 313   1              uchar isBreak;
 314   1              LCDCls();
 315   1              capSel=CAPSEL_LOWR;
 316   1              delaynms(500);
 317   1              LCDPrintLine(0,0,disconnectStr);
 318   1              PressAnyKey();
 319   1      
 320   1              LCDPrintLine(0,0,mearsStr);
 321   1              pwmTCount=0;
 322   1              pwmNCount=0;
 323   1              SwitchTimerFun(TIMERFUN_PWM);
 324   1              StartTimer();
 325   1              while(1){
 326   2                      if(isTimerEvent){
 327   3                              if(pwmTCount==17){                                      
 328   4                                      break;
 329   4                              }
 330   3      
 331   3                              if(t1IntrTimes==201){                           
 332   4                                      ++pwmNCount;                                    
 333   4                                      t1IntrTimes=1;
 334   4                              }
 335   3                              if(t1IntrTimes<=7+pwmTCount)
 336   3                                      servoConOut=1;                                  
 337   3                              else
 338   3                                      servoConOut=0;
 339   3      
 340   3                              if(pwmNCount==100){
 341   4                                      servoConOut=0;
 342   4                                      pwmNCount=0;
 343   4                                      SwitchTimerFun(TIMERFUN_FREQ_MEASRURE); 
 344   4                                      StartTimer();
 345   4                                      while(!isTimerEvent);
 346   4                                      GetRVal();                                              
 347   4                                      pwmRVal[pwmTCount++]=curRValue; 
 348   4                                      SwitchTimerFun(TIMERFUN_PWM);   
 349   4                                      StartTimer();                                   
 350   4                              }
 351   3                      }
 352   2              }
 353   1              curShow=0;
 354   1              isBreak=0;
 355   1              LCDCls();
 356   1              LCDPrintFloat(0,0,pwmRVal[curShow]);
 357   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);
 358   1              StartTimer();
 359   1              while(!isBreak){
 360   2                      if(isKeyEvents){
C51 COMPILER V9.01   MENU                                                                  07/22/2018 14:28:58 PAGE 7   

 361   3                              if(key1Events){
 362   4                                      switch(key1Events){
 363   5                                              case SHORT_PRESS:
 364   5                                                      curShow=(++curShow)%17;
 365   5                                                      break;
 366   5                                              case LONG_PRESS:
 367   5                                                      curShow=16;
 368   5                                                      break;
 369   5                                      }
 370   4                              }
 371   3                              else if(key2Events){
 372   4                                      switch(key2Events){
 373   5                                              case SHORT_PRESS:
 374   5                                                      curShow= (--curShow)<0?16:curShow;
 375   5                                                      break;
 376   5                                              case LONG_PRESS:
 377   5                                                      curShow=0;
 378   5                                                      break;
 379   5                                      }
 380   4                              }
 381   3                              else{
 382   4                                      switch(key3Events){
 383   5                                              case SHORT_PRESS:
 384   5                                                      isBreak=1;
 385   5                                                      break;
 386   5                                              default:
 387   5                                                      break;
 388   5                                      }
 389   4                              }
 390   3                              LCDPrintFloat(0,0,pwmRVal[curShow]);
 391   3                              RstKeyEvents();
 392   3                      }
 393   2              }
 394   1              LCDPrintLine(0,0,connectStr);
 395   1              PressAnyKey();
 396   1              capSel=CAPSEL_LOWR;
 397   1      }
 398          /**
 399           * ËÆæÁΩÆÁ≠õÈÄâÊù°‰ª∂
 400           * @Author   Xiaobo     Yang
 401           * @DateTime 2018-07-21
 402           * @Summury
 403           */
 404          void MenuOpSetSieve (){
 405   1              uchar curDigit=0;
 406   1              uchar isBreak=0;
 407   1              LCDCls();
 408   1              LCDPrintNumFixdgt(0,0,rNumPart,3);
 409   1              LCDPrintChar(3,0,rUnit);
 410   1              LCDPrintChar(curDigit,1,'^');
 411   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);
 412   1              StartTimer();
 413   1              while(!isBreak){
 414   2                      if(isKeyEvents){
 415   3                              if(key1Events){
 416   4                                      switch(key1Events){
 417   5                                              case SHORT_PRESS:
 418   5                                                      switch(curDigit){
 419   6                                                              case 0:
 420   6                                                                      rNumPart=(rNumPart+100)%1000;
 421   6                                                                      break;
 422   6                                                              case 1:
C51 COMPILER V9.01   MENU                                                                  07/22/2018 14:28:58 PAGE 8   

 423   6                                                                      rNumPart=(rNumPart+10)%1000;
 424   6                                                                      break;
 425   6                                                              case 2:
 426   6                                                                      rNumPart=(rNumPart+1)%1000;
 427   6                                                                      break;
 428   6                                                              case 3:
 429   6                                                                      switch(rUnit){
 430   7                                                                              case 0x20:
 431   7                                                                                      rUnit='K';
 432   7                                                                                      break;
 433   7                                                                              case 'K':
 434   7                                                                                      rUnit='M';
 435   7                                                                                      break;
 436   7                                                                              case 'M':
 437   7                                                                                      rUnit=0x20;
 438   7                                                                                      break;
 439   7                                                                      }
 440   6                                                              break;
 441   6                                                      }
 442   5                                                      break;
 443   5                                              case LONG_PRESS:
 444   5                                                      switch(curDigit){
 445   6                                                              case 0:
 446   6                                                                      rNumPart%=100;
 447   6                                                                      break;
 448   6                                                              case 1:
 449   6                                                                      rNumPart-=((rNumPart%100)/10)*10;
 450   6                                                                      break;
 451   6                                                              case 2:
 452   6                                                                      rNumPart-=rNumPart%10;
 453   6                                                                      break;
 454   6                                                              case 3:
 455   6                                                                      rUnit=0x20;
 456   6                                                                      break;
 457   6                                                      }
 458   5                                                      break;
 459   5                                      }
 460   4                                      LCDPrintNumFixdgt(0,0,rNumPart,3);
 461   4                                      LCDPrintChar(3,0,rUnit);
 462   4                              }
 463   3                              else if(key2Events){
 464   4                                      LCDPrintChar(curDigit,1,0x20);
 465   4                                      switch(key2Events){
 466   5                                              case SHORT_PRESS:
 467   5                                                      curDigit=++curDigit%4;
 468   5                                                      break;
 469   5                                              case LONG_PRESS:
 470   5                                                      if(curDigit==3){
 471   6                                                              curDigit=0;
 472   6                                                      }
 473   5                                                      else{
 474   6                                                              curDigit=3;
 475   6                                                      }
 476   5                                                      break;
 477   5                                      }
 478   4                                      LCDPrintChar(curDigit,1,'^');
 479   4                              }
 480   3                              else{
 481   4                                      switch(key3Events){
 482   5                                              case SHORT_PRESS:
 483   5                                                      isBreak=1;
 484   5                                                      break;
C51 COMPILER V9.01   MENU                                                                  07/22/2018 14:28:58 PAGE 9   

 485   5                                              default:
 486   5                                                      break;
 487   5                                      }
 488   4                              }
 489   3                              RstKeyEvents(); 
 490   3                      }
 491   2              }
 492   1              curDigit=0;
 493   1              isBreak=0;
 494   1              LCDCls();
 495   1              LCDPrintNumFixdgt(0,0,errTolrE2,2);
 496   1              LCDPrintChar(2,0,'%');
 497   1              LCDPrintChar(curDigit,1,'^');
 498   1              while(!isBreak){
 499   2                      if(isKeyEvents){
 500   3                              if(key1Events){
 501   4                                      switch(key1Events){
 502   5                                              case SHORT_PRESS:
 503   5                                                      switch(curDigit){
 504   6                                                              case 0:
 505   6                                                                      errTolrE2=(errTolrE2+10)%100;
 506   6                                                                      break;
 507   6                                                              case 1:
 508   6                                                                      errTolrE2=(++errTolrE2)%100;
 509   6                                                                      break;
 510   6                                                      }
 511   5                                                      break;
 512   5                                              case LONG_PRESS:
 513   5                                                      switch(curDigit){
 514   6                                                              case 0:
 515   6                                                                      errTolrE2%=10;
 516   6                                                                      break;
 517   6                                                              case 1:
 518   6                                                                      errTolrE2-=errTolrE2%10;
 519   6                                                                      break;
 520   6                                                      }
 521   5                                                      break;
 522   5                                      }
 523   4                                      LCDPrintNumFixdgt(0,0,errTolrE2,2);
 524   4                              }
 525   3                              else if(key2Events){
 526   4                                      LCDPrintChar(curDigit,1,0x20);
 527   4                                      switch(key2Events){
 528   5                                              case SHORT_PRESS:
 529   5                                                      curDigit=(++curDigit)%2;
 530   5                                                      break;
 531   5                                              case LONG_PRESS:
 532   5                                                      curDigit=0;
 533   5                                                      break;
 534   5                                      }
 535   4                                      LCDPrintChar(curDigit,1,'^');
 536   4                              }
 537   3                              else{
 538   4                                      switch(key3Events){
 539   5                                              case SHORT_PRESS:
 540   5                                                      isBreak=1;
 541   5                                                      break;
 542   5                                              default:
 543   5                                                      break;
 544   5                                      }
 545   4                              }
 546   3                              RstKeyEvents();
C51 COMPILER V9.01   MENU                                                                  07/22/2018 14:28:58 PAGE 10  

 547   3                      }
 548   2              }
 549   1              switch(rUnit){
 550   2                      case 0x20:
 551   2                              sieveRVal=rNumPart;
 552   2                              break;
 553   2                      case 'K':
 554   2                              sieveRVal=rNumPart*1e3;
 555   2                              break;
 556   2                      case 'M':
 557   2                              sieveRVal=rNumPart*1e6;
 558   2                              break;
 559   2              }
 560   1              errTolr=(float) errTolrE2/100.0;
 561   1              LCDCls();
 562   1              LCDPrintNumFixdgt(0,0,rNumPart,3);
 563   1              LCDPrintChar(3,0,rUnit);
 564   1              LCDPrintNumFixdgt(0,1,errTolrE2,2);
 565   1              LCDPrintFloat(8,0,sieveRVal);
 566   1              LCDPrintFloat(8,1,errTolr);
 567   1              delaynms(3000);
 568   1      }
 569          
 570          
 571          
 572          
 573          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1976    ----
   CONSTANT SIZE    =    270    ----
   XDATA SIZE       =     68    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     31       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
