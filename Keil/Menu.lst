C51 COMPILER V9.01   MENU                                                                  07/21/2018 20:48:59 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MENU
OBJECT MODULE PLACED IN .\Menu.obj
COMPILER INVOKED BY: D:\Kell\C51\BIN\C51.EXE ..\Src\Menu.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Menu.lst) OBJECT(.\Menu.obj
                    -)

line level    source

   1          #include "RM.h"
   2          #include "Menu.h"
   3          #include "Timer.h"
   4          #include "Key.h"
   5          #include "LCD1602.h"
   6          
   7          #define MENUID_DEBUG_MODE_ON    0                                       //ËèúÂçïÈÄâÈ°πIDÁöÑÂÆèÂÆö‰πâ
   8          #define MENUID_SIEVE_MODE_ON    1
   9          #define MENUID_SET_SIEVE        3
  10          #define MENUID_START_PLOT       4
  11          #define MENUID_RESET_DEVICE     5
  12          #define MENUID_EXIT             6
  13          #define MENUID_DEBUG_YES                7
  14          #define MENUID_DEBUG_NO                 8
  15          #define MENUID_SIEVE_YES        9               
  16          #define MENUID_SIEVE_NO                 10              
  17          
  18          #define MENU_OPTION_NUM_MAIN    6                                       //ËèúÂçïÊù°ÁõÆÊï∞ÁöÑÂÆèÂÆö‰πâ
  19          #define MENU_OPTION_NUM_YN              2
  20          
  21          typedef struct MenuRecord *ptrToMenuRecord;                     //ÂÆö‰πâÊåáÂêëËèúÂçïËÆ∞ÂΩïÁöÑÊåáÈíà
  22          typedef ptrToMenuRecord Menu;                                           //ÊåáÂêëËèúÂçïËÆ∞ÂΩïÁöÑÊåáÈíàÁõ¥Êé•Âè´Menu
  23          typedef struct MenuOp *ptrToMenuOp;                                     //ÊåáÂêëËèúÂçïÈÄâÈ°πÁöÑÊåáÈíà
  24          
  25          struct MenuOp{                                                                          //ËèúÂçïÈÄâÈ°πÁöÑÁªìÊûÑ
  26                  uchar opID;                                                                             //ÈÄâÈ°πÁöÑID
  27                  char *opString;                                                         //ÈÄâÈ°πÊòæÁ§∫ÁöÑÂ≠óÁ¨¶‰∏≤
  28                  Menu subMenu;                                                                   //ÈÄâÈ°πÁöÑÂ≠êËèúÂçï
  29                  void (*pOpFunc) (void);                                                 //ÈÄâÊã©ËØ•ÈÄâÈ°πÊâßË°åÁöÑÂáΩÊï∞
  30          };
  31          
  32          struct MenuRecord{                                                                      //ËèúÂçïËÆ∞ÂΩïÁöÑÁªìÊûÑ
  33                  uchar opNum;                                                                    //ËØ•ËèúÂçïÈÄâÈ°πÁöÑÊù°ÁõÆÊï∞
  34                  Menu superMenu;                                                                 //ËØ•ËèúÂçïÁöÑ‰∏ä‰∏ÄÁ∫ßËèúÂçï
  35                  ptrToMenuOp OpArray;                                                    //ËØ•ËèúÂçïÁöÑÊù°ÁõÆÊï∞ÁªÑ
  36          };
  37          
  38          static code struct MenuOp debugYNOpArray[MENU_OPTION_NUM_YN]={                                                  //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  39                  {MENUID_DEBUG_YES,"Yes",NULL,MenuOpYN},
  40                  {MENUID_DEBUG_NO,"No",NULL,MenuOpYN}
  41          };
  42          static struct MenuRecord debugYNMenuRecord={MENU_OPTION_NUM_YN,NULL,debugYNOpArray};            //Yes No  ËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  43          static code Menu debugYNMenu=&debugYNMenuRecord;                                                                                                //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  44          
  45          static code struct MenuOp sieveYNOpArray[MENU_OPTION_NUM_YN]={                                                  //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  46                  {MENUID_SIEVE_YES,"Yes",NULL,MenuOpYN},
  47                  {MENUID_SIEVE_NO,"No",NULL,MenuOpYN}
  48          };
  49          static struct MenuRecord sieveYNMenuRecord={MENU_OPTION_NUM_YN,NULL,sieveYNOpArray};            //Yes No  ËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  50          static code Menu sieveYNMenu=&sieveYNMenuRecord;                                                                                                //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  51          
  52          static code struct MenuOp MainMenuOpArray[MENU_OPTION_NUM_MAIN]={                                                       //mainËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ                             
C51 COMPILER V9.01   MENU                                                                  07/21/2018 20:48:59 PAGE 2   

  53                  {MENUID_DEBUG_MODE_ON,"Debug Mode On",&debugYNMenuRecord,NULL},
  54                  {MENUID_SIEVE_MODE_ON,"Sieve Mode On",&sieveYNMenuRecord,NULL},
  55                  {MENUID_SET_SIEVE,"Set Sieve",NULL,MenuOpSetSieve},
  56                  {MENUID_START_PLOT,"Start Plot",NULL,MenuOpStartPlot},
  57                  {MENUID_RESET_DEVICE,"Reset Device",NULL,MenuOpRstDev},
  58                  {MENUID_EXIT,"Exit",NULL,MenuOpExit}
  59          };
  60          static code struct MenuRecord mainMenuRecord={MENU_OPTION_NUM_MAIN,NULL,MainMenuOpArray};       //mainËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  61          static code Menu mainMenu=&mainMenuRecord;                                                                                                  //Áî®Âè´ÂÅömainMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  62          
  63          static Menu  curMenu;                                                           //ÊåáÂêëÂΩìÂâçËèúÂçïÁöÑËÆ∞ÂΩï
  64          static uchar curOp;                                                                     //ÂΩìÂâçÊù°ÁõÆ
  65          
  66          static bit isExit;                                                                      //Ê∂àÊÅØÂèòÈáèÔºöÊòØÂê¶ÈÄÄÂá∫ËèúÂçï
  67          
  68          extern bit   isSieveOn;                                                         //Ê∂àÊÅØÂèòÈáè:Á≠õÈÄâÊòØÂê¶ÊâìÂºÄ
  69          extern float sieveRVal;                                                         //Á≠õÈÄâÁîµÈòªÁöÑ‰∏≠ÂøÉÂÄº
  70          extern float errTolr;                                                           //ËØØÂ∑ÆÈôê
  71          extern bit   isDebug;                                                           //Ê∂àÊÅØÂèòÈáè:Ë∞ÉËØïÊ®°ÂºèÊâìÂºÄ
  72          
  73          sbit    Led1 = P1^0;                                                            //LedÂèòÈáè
  74          sbit    Led2 = P1^1;
  75          sbit    Led3 = P1^2;
  76          
  77          extern bit isKeyEvents;
  78          extern bit isTimerEvent;
  79          
  80          extern uchar key1Events;
  81          extern uchar key2Events;
  82          extern uchar key3Events;
  83          
  84          static uchar rNumPart;                                                          //Á≠õÈÄâÁîµÈòªÁöÑ‰∏â‰ΩçÊï∞Â≠óÈÉ®ÂàÜ
  85          static uchar rUnit;                                                                     //Á≠õÈÄâÁîµÈòªÁöÑÂçï‰ΩçÔºåÂèØ‰ª•ÊòØ 0x20 'K' 'M'
  86          static uchar errTolrE2;                                                         //ËØØÂ∑ÆÈôê*100
  87          /**
  88           * ÂàùÂßãÂåñËèúÂçï
  89           * @Author   Xiaobo     Yang
  90           * @DateTime 2018-07-21
  91           * @Summury
  92           */
  93          void InitialMenu(){
  94   1              debugYNMenu->superMenu=mainMenu;                                //ËèúÂçïÂâçÂêé‰∫íÊåáÔºåÂõ†Ê≠§‰∏ÄÈÉ®ÂàÜÊåáÂêëÂ∑•‰ΩúË¶ÅÂà∞Á®ãÂ∫èÂÆåÊàê
  95   1              sieveYNMenu->superMenu=mainMenu;
  96   1              curMenu=mainMenu;                                                               //ÂàùÂßãÂåñÊâÄÊúâÊúâÂÖ≥ÂÖ®Â±ÄÂèòÈáè
  97   1              curOp=0;
  98   1              isExit=0;
  99   1              isSieveOn=0;
 100   1              sieveRVal=0.0;
 101   1              errTolr=0.0;
 102   1              rNumPart=0;
 103   1              rUnit=0x20;
 104   1              errTolrE2=0;
 105   1              isDebug=1;
 106   1      }
 107          /**
 108           * ÊâìÂºÄËèúÂçï
 109           * @Author   Xiaobo     Yang
 110           * @DateTime 2018-07-21
 111           * @Summury
 112           */
 113          void MenuImpl(){
C51 COMPILER V9.01   MENU                                                                  07/21/2018 20:48:59 PAGE 3   

 114   1              curMenu=mainMenu;                                                               //‰ªéÂ§¥ÂºÄÂßãÊòæÁ§∫ËèúÂçï
 115   1              curOp=0;
 116   1              isExit=0;
 117   1              ShowMenu();
 118   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);                              //ÂºÄÂßãÈîÆÁõòÊâ´Êèè
 119   1              StartTimer();
 120   1              while(!isExit){
 121   2                      if(isKeyEvents){
 122   3                              SwitchTimerFun(TIMERFUN_HALT);                  //TODO:ÊàñËÆ∏ÂèØ‰ª•‰ºòÂåñÊéâ
 123   3                              MenuKeyTreat();
 124   3                              SwitchTimerFun(TIMERFUN_KEY_SCAN);              //ÈáçÂêØÈîÆÁõòÊâ´Êèè
 125   3                              StartTimer();
 126   3                      }
 127   2              }
 128   1      }
 129          /**
 130           * ÊòæÁ§∫ËèúÂçï
 131           * @Author   Xiaobo     Yang
 132           * @DateTime 2018-07-21
 133           * @Summury
 134           */
 135          void ShowMenu(){
 136   1              LCDCls();
 137   1              if(curOp!=0){
 138   2                      LCDMoveCursor(1,0);                                                                             //Ê≠§Â§ÑÊúâËé´ÂêçÂÖ∂Â¶ôÁöÑbugÔºåÈúÄË¶Å‰∏ìÈó®ÈáçËÆæÂÖâÊ†á
 139   2                      LCDPrintStr(1,0,curMenu->OpArray[curOp-1].opString);
 140   2                      LCDPrintStr(1,1,curMenu->OpArray[curOp].opString);
 141   2                      LCDPrintChar(0,1,'>');
 142   2              }
 143   1              else{
 144   2                      LCDMoveCursor(1,0);
 145   2                      LCDPrintStr(1,0,curMenu->OpArray[curOp].opString);
 146   2                      LCDPrintStr(1,1,curMenu->OpArray[curOp+1].opString);
 147   2                      LCDPrintChar(0,0,'>');
 148   2              }
 149   1      }
 150          /**
 151           * Â§ÑÁêÜËèúÂçïÊ®°Âºè‰∏ãÁöÑÊåâÈîÆ‰ø°ÊÅØ
 152           * @Author   Xiaobo     Yang
 153           * @DateTime 2018-07-21
 154           * @Summury
 155           */
 156          void MenuKeyTreat(){
 157   1              if(key1Events){                                                                                 //key1‰ºòÂÖàÁ∫ß>key2‰ºòÂÖàÁ∫ß>key3‰ºòÂÖàÁ∫ß
 158   2                      switch(key1Events){
 159   3                              case SHORT_PRESS:
 160   3                                      curOp=(++curOp)%(curMenu->opNum);                               //Âêë‰∏ãÈÄâÊã©
 161   3                                      if(curOp==1) Led1=1;
 162   3                                      ShowMenu();
 163   3                                      break;
 164   3                              default:
 165   3                                      break;
 166   3                      }
 167   2              }
 168   1              else if(key2Events){
 169   2                      switch(key2Events){
 170   3                              case SHORT_PRESS:
 171   3                                      curOp=(--curOp)%(curMenu->opNum);                               //Âêë‰∏äÈÄâÊã©
 172   3                                      ShowMenu();
 173   3                                      break;
 174   3                              default:
 175   3                                      break;
C51 COMPILER V9.01   MENU                                                                  07/21/2018 20:48:59 PAGE 4   

 176   3                      }
 177   2              }
 178   1              else{
 179   2                      switch(key3Events){
 180   3                              case SHORT_PRESS:
 181   3                              if(curMenu->OpArray[curOp].subMenu!=NULL){
 182   4                                      curMenu=curMenu->OpArray[curOp].subMenu;        //ËøõÂÖ•Â≠êËèúÂçï
 183   4                                      curOp=0;
 184   4                                      ShowMenu();
 185   4                              }
 186   3                              else{
 187   4                                      KeyInitial();                                                           //ÂàùÂßãÂåñÂ§ñËÆæÔºåÊó∂ÈíüÂ∑≤ÁªèÂú®MenuImpl‰∏≠ÂÅúÊ≠¢
 188   4                                      isExit=1;                                                                       //ËÆæÂÆöÈÄÄÂá∫Ê®°Âºè
 189   4                                      (*(curMenu->OpArray[curOp].pOpFunc)) ();        //ÊâßË°åÈÄâÈ°πÁöÑÂáΩÊï∞
 190   4                              }       
 191   3                                      break;
 192   3                              case LONG_PRESS:                                                                //ÈïøÊåâÂèØ‰ª•ÂõûÂà∞‰∏äÁ∫ßËèúÂçï
 193   3                                      if(curMenu->superMenu!=NULL){
 194   4                                              curMenu=curMenu->superMenu;
 195   4                                              curOp=0;
 196   4                                              ShowMenu();
 197   4                                      }
 198   3                                      break;
 199   3                              default:
 200   3                                      break;
 201   3                      }
 202   2              }
 203   1              RstKeyEvents();
 204   1      }
 205          /**
 206           * ‰ªÄ‰πàÈÉΩ‰∏çÂÅö
 207           * @Author   Xiaobo     Yang
 208           * @DateTime 2018-07-21
 209           * @Summury
 210           */
 211          void MenuOpExit(){
 212   1              return;
 213   1      }
 214          /**
 215           * Âà©Áî®IAP_CONTRËøõË°åËΩØ‰ª∂Â§ç‰Ωç
 216           * @Author   Xiaobo     Yang
 217           * @DateTime 2018-07-21
 218           * @Summury
 219           */
 220          void MenuOpRstDev(){
 221   1              // uint i=6000;
 222   1              // Led3=Led2=Led1=0;                                                                            //ÁÅ≠ÁÅØÔºåÁ≠âÂæÖÊøÄÂä®‰∫∫ÂøÉÁöÑ‰∏ÄÂàª
 223   1              // LCDPrintScreen("Press Any Key To","Stop RESET!");
 224   1              // SwitchTimerFun(TIMERFUN_KEY_SCAN);
 225   1              // StartTimer();
 226   1              // while(i){
 227   1              //      if(isTimerEvent){
 228   1              //              isTimerEvent=0;
 229   1              //              i--;                                                                                    //ÊØè0.5msËÆ©iÂáè‰∏ÄÔºå1S‰∫Æ‰∏Ä‰∏™ÁÅØ
 230   1              //              if(i==4000){
 231   1              //                      Led3=1;
 232   1              //              }
 233   1              //              else if(i==2000){
 234   1              //                      Led2=1;
 235   1              //              }
 236   1              //      }
 237   1              //      if(isKeyEvents){                                                                        //Â¶ÇÊúâÈîÆÁõò‰∫ã‰ª∂ÔºåÁ´ãÂç≥‰∏≠Êñ≠ÂáΩÊï∞ÊâßË°å
C51 COMPILER V9.01   MENU                                                                  07/21/2018 20:48:59 PAGE 5   

 238   1              //              return;
 239   1              //      }
 240   1              // }
 241   1              // Led1=1;
 242   1              // delaynms(1000);
 243   1              // ISP_CONTR = 0x60;                                                                            //Â§ç‰Ωç
 244   1              return;
 245   1      }
 246          /**
 247           * YNËèúÂçïÊâßË°åÔºåÁî®‰∫éÊîπÂèòdebugÂíåsieveÊ®°Âºè
 248           * @Author   Xiaobo     Yang
 249           * @DateTime 2018-07-21
 250           * @Summury
 251           */
 252          void MenuOpYN(){
 253   1              switch(curMenu->OpArray[curOp].opID){
 254   2                      case MENUID_DEBUG_YES:
 255   2                              isDebug=1;
 256   2                              break;
 257   2                      case MENUID_DEBUG_NO:
 258   2                              isDebug=0;
 259   2                              break;
 260   2                      case MENUID_SIEVE_YES:
 261   2                              isSieveOn=1;
 262   2                              break;
 263   2                      case MENUID_SIEVE_NO:
 264   2                              isSieveOn=0;
 265   2                              break;
 266   2              }
 267   1      }
 268          /**
 269           * ËΩ¨Âä®ËàµÊú∫ÁîªÊõ≤Á∫ø
 270           * @Author   Xiaobo     Yang
 271           * @DateTime 2018-07-21
 272           * @Summury
 273           */
 274          void MenuOpStartPlot(){
 275   1              //////////////////////
 276   1              //TODO:NOT FINISHED //
 277   1              //////////////////////
 278   1              return;
 279   1      }
 280          /**
 281           * ËÆæÁΩÆÁ≠õÈÄâÊù°‰ª∂
 282           * @Author   Xiaobo     Yang
 283           * @DateTime 2018-07-21
 284           * @Summury
 285           */
 286          void MenuOpSetSieve (){
 287   1              uchar curDigit=0;
 288   1              uchar isBreak=0;
 289   1              LCDCls();
 290   1              LCDPrintNumFixdgt(0,0,rNumPart,3);
 291   1              LCDPrintChar(3,0,rUnit);
 292   1              LCDPrintChar(curDigit,1,'^');
 293   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);
 294   1              StartTimer();
 295   1              while(!isBreak){
 296   2                      if(isKeyEvents){
 297   3                              if(key1Events){
 298   4                                      switch(key1Events){
 299   5                                              case SHORT_PRESS:
C51 COMPILER V9.01   MENU                                                                  07/21/2018 20:48:59 PAGE 6   

 300   5                                                      switch(curDigit){
 301   6                                                              case 0:
 302   6                                                                      rNumPart=(rNumPart+100)%1000;
 303   6                                                                      break;
 304   6                                                              case 1:
 305   6                                                                      rNumPart=(rNumPart+10)%1000;
 306   6                                                                      break;
 307   6                                                              case 2:
 308   6                                                                      rNumPart=(rNumPart+1)%1000;
 309   6                                                                      break;
 310   6                                                              case 3:
 311   6                                                                      switch(rUnit){
 312   7                                                                              case 0x20:
 313   7                                                                                      rUnit='K';
 314   7                                                                                      break;
 315   7                                                                              case 'K':
 316   7                                                                                      rUnit='M';
 317   7                                                                                      break;
 318   7                                                                              case 'M':
 319   7                                                                                      rUnit=0x20;
 320   7                                                                                      break;
 321   7                                                                      }
 322   6                                                              break;
 323   6                                                      }
 324   5                                                      break;
 325   5                                              case LONG_PRESS:
 326   5                                                      switch(curDigit){
 327   6                                                              case 0:
 328   6                                                                      rNumPart%=100;
 329   6                                                                      break;
 330   6                                                              case 1:
 331   6                                                                      rNumPart-=((rNumPart%100)/10)*10;
 332   6                                                                      break;
 333   6                                                              case 2:
 334   6                                                                      rNumPart-=rNumPart%10;
 335   6                                                                      break;
 336   6                                                              case 3:
 337   6                                                                      rUnit=0x20;
 338   6                                                                      break;
 339   6                                                      }
 340   5                                                      break;
 341   5                                      }
 342   4                                      LCDPrintNumFixdgt(0,0,rNumPart,3);
 343   4                                      LCDPrintChar(3,0,rUnit);
 344   4                              }
 345   3                              else if(key2Events){
 346   4                                      LCDPrintChar(curDigit,1,0x20);
 347   4                                      switch(key2Events){
 348   5                                              case SHORT_PRESS:
 349   5                                                      curDigit=++curDigit%4;
 350   5                                                      break;
 351   5                                              case LONG_PRESS:
 352   5                                                      if(curDigit==3){
 353   6                                                              curDigit=0;
 354   6                                                      }
 355   5                                                      else{
 356   6                                                              curDigit=3;
 357   6                                                      }
 358   5                                                      break;
 359   5                                      }
 360   4                                      LCDPrintChar(curDigit,1,'^');
 361   4                              }
C51 COMPILER V9.01   MENU                                                                  07/21/2018 20:48:59 PAGE 7   

 362   3                              else{
 363   4                                      switch(key3Events){
 364   5                                              case SHORT_PRESS:
 365   5                                                      isBreak=1;
 366   5                                                      break;
 367   5                                              default:
 368   5                                                      break;
 369   5                                      }
 370   4                              }
 371   3                              RstKeyEvents(); 
 372   3                      }
 373   2              }
 374   1              curDigit=0;
 375   1              isBreak=0;
 376   1              LCDCls();
 377   1              LCDPrintNumFixdgt(0,0,errTolrE2,2);
 378   1              LCDPrintChar(2,0,'%');
 379   1              LCDPrintChar(curDigit,1,'^');
 380   1              while(!isBreak){
 381   2                      if(isKeyEvents){
 382   3                              if(key1Events){
 383   4                                      switch(key1Events){
 384   5                                              case SHORT_PRESS:
 385   5                                                      switch(curDigit){
 386   6                                                              case 0:
 387   6                                                                      errTolrE2=(errTolrE2+10)%100;
 388   6                                                                      break;
 389   6                                                              case 1:
 390   6                                                                      errTolrE2=(++errTolrE2)%100;
 391   6                                                                      break;
 392   6                                                      }
 393   5                                                      break;
 394   5                                              case LONG_PRESS:
 395   5                                                      switch(curDigit){
 396   6                                                              case 0:
 397   6                                                                      errTolrE2%=10;
 398   6                                                                      break;
 399   6                                                              case 1:
 400   6                                                                      errTolrE2-=errTolrE2%10;
 401   6                                                                      break;
 402   6                                                      }
 403   5                                                      break;
 404   5                                      }
 405   4                                      LCDPrintNumFixdgt(0,0,errTolrE2,2);
 406   4                              }
 407   3                              else if(key2Events){
 408   4                                      LCDPrintChar(curDigit,1,0x20);
 409   4                                      switch(key2Events){
 410   5                                              case SHORT_PRESS:
 411   5                                                      curDigit=(++curDigit)%2;
 412   5                                                      break;
 413   5                                              case LONG_PRESS:
 414   5                                                      curDigit=0;
 415   5                                                      break;
 416   5                                      }
 417   4                                      LCDPrintChar(curDigit,1,'^');
 418   4                              }
 419   3                              else{
 420   4                                      switch(key3Events){
 421   5                                              case SHORT_PRESS:
 422   5                                                      isBreak=1;
 423   5                                                      break;
C51 COMPILER V9.01   MENU                                                                  07/21/2018 20:48:59 PAGE 8   

 424   5                                              default:
 425   5                                                      break;
 426   5                                      }
 427   4                              }
 428   3                              RstKeyEvents();
 429   3                      }
 430   2              }
 431   1              switch(rUnit){
 432   2                      case 0x20:
 433   2                              sieveRVal=rNumPart;
 434   2                              break;
 435   2                      case 'K':
 436   2                              sieveRVal=rNumPart*1e3;
 437   2                              break;
 438   2                      case 'M':
 439   2                              sieveRVal=rNumPart*1e6;
 440   2                              break;
 441   2              }
 442   1              errTolr=(float) errTolrE2/100.0;
 443   1              LCDPrintFloat(0,0,sieveRVal);
 444   1              LCDPrintFloat(0,1,errTolr);
 445   1              delaynms(3000);
 446   1      }
 447          
 448          
 449          
 450          
 451          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1316    ----
   CONSTANT SIZE    =    190    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     21       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
