C51 COMPILER V9.01   MENU                                                                  07/21/2018 23:28:03 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MENU
OBJECT MODULE PLACED IN .\Menu.obj
COMPILER INVOKED BY: D:\Kell\C51\BIN\C51.EXE ..\Src\Menu.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Menu.lst) OBJECT(.\Menu.obj
                    -)

line level    source

   1          #include "RM.h"
   2          #include "Menu.h"
   3          #include "Timer.h"
   4          #include "Key.h"
   5          #include "LCD1602.h"
   6          
   7          #define MENUID_DEBUG_MODE_ON    0                                       //ËèúÂçïÈÄâÈ°πIDÁöÑÂÆèÂÆö‰πâ
   8          #define MENUID_SIEVE_MODE_ON    1
   9          #define MENUID_SET_SIEVE        3
  10          #define MENUID_START_PLOT       4
  11          #define MENUID_RESET_DEVICE     5
  12          #define MENUID_EXIT             6
  13          #define MENUID_DEBUG_YES                7
  14          #define MENUID_DEBUG_NO                 8
  15          #define MENUID_SIEVE_YES        9               
  16          #define MENUID_SIEVE_NO                 10              
  17          
  18          #define MENU_OPTION_NUM_MAIN    6                                       //ËèúÂçïÊù°ÁõÆÊï∞ÁöÑÂÆèÂÆö‰πâ
  19          #define MENU_OPTION_NUM_YN              2
  20          
  21          typedef struct MenuRecord *ptrToMenuRecord;                     //ÂÆö‰πâÊåáÂêëËèúÂçïËÆ∞ÂΩïÁöÑÊåáÈíà
  22          typedef ptrToMenuRecord   Menu;                                         //ÊåáÂêëËèúÂçïËÆ∞ÂΩïÁöÑÊåáÈíàÁõ¥Êé•Âè´Menu
  23          typedef struct MenuOp     *ptrToMenuOp;                         //ÊåáÂêëËèúÂçïÈÄâÈ°πÁöÑÊåáÈíà
  24          
  25          struct MenuOp{                                                                          //ËèúÂçïÈÄâÈ°πÁöÑÁªìÊûÑ
  26                  uchar opID;                                                                             //ÈÄâÈ°πÁöÑID
  27                  char *opString;                                                                 //ÈÄâÈ°πÊòæÁ§∫ÁöÑÂ≠óÁ¨¶‰∏≤
  28                  Menu subMenu;                                                                   //ÈÄâÈ°πÁöÑÂ≠êËèúÂçï
  29                  void (*pOpFunc) (void);                                                 //ÈÄâÊã©ËØ•ÈÄâÈ°πÊâßË°åÁöÑÂáΩÊï∞
  30          };
  31          
  32          struct MenuRecord{                                                                      //ËèúÂçïËÆ∞ÂΩïÁöÑÁªìÊûÑ
  33                  uchar opNum;                                                                    //ËØ•ËèúÂçïÈÄâÈ°πÁöÑÊù°ÁõÆÊï∞
  34                  Menu superMenu;                                                                 //ËØ•ËèúÂçïÁöÑ‰∏ä‰∏ÄÁ∫ßËèúÂçï
  35                  ptrToMenuOp OpArray;                                                    //ËØ•ËèúÂçïÁöÑÊù°ÁõÆÊï∞ÁªÑ
  36          };
  37          
  38          static code struct MenuOp debugYNOpArray[MENU_OPTION_NUM_YN]={                                                          //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  39                  {MENUID_DEBUG_YES,"Yes",NULL,MenuOpYN},
  40                  {MENUID_DEBUG_NO,"No",NULL,MenuOpYN}
  41          };
  42          static struct MenuRecord debugYNMenuRecord={MENU_OPTION_NUM_YN,NULL,debugYNOpArray};            //Yes No  ËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  43          static code Menu debugYNMenu=&debugYNMenuRecord;                                                                                        //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  44          
  45          static code struct MenuOp sieveYNOpArray[MENU_OPTION_NUM_YN]={                                                          //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  46                  {MENUID_SIEVE_YES,"Yes",NULL,MenuOpYN},
  47                  {MENUID_SIEVE_NO,"No",NULL,MenuOpYN}
  48          };
  49          static struct MenuRecord sieveYNMenuRecord={MENU_OPTION_NUM_YN,NULL,sieveYNOpArray};            //Yes No  ËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  50          static code Menu sieveYNMenu=&sieveYNMenuRecord;                                                                                        //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  51          
  52          static code struct MenuOp MainMenuOpArray[MENU_OPTION_NUM_MAIN]={                                                       //mainËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ                             
C51 COMPILER V9.01   MENU                                                                  07/21/2018 23:28:03 PAGE 2   

  53                  {MENUID_DEBUG_MODE_ON,"Debug Mode On",&debugYNMenuRecord,NULL},
  54                  {MENUID_SIEVE_MODE_ON,"Sieve Mode On",&sieveYNMenuRecord,NULL},
  55                  {MENUID_SET_SIEVE,"Set Sieve",NULL,MenuOpSetSieve},
  56                  {MENUID_START_PLOT,"Start Plot",NULL,MenuOpStartPlot},
  57                  {MENUID_RESET_DEVICE,"Reset Device",NULL,MenuOpRstDev},
  58                  {MENUID_EXIT,"Exit",NULL,MenuOpExit}
  59          };
  60          static code struct MenuRecord mainMenuRecord={MENU_OPTION_NUM_MAIN,NULL,MainMenuOpArray};       //mainËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  61          static code Menu mainMenu=&mainMenuRecord;                                                                                                  //Áî®Âè´ÂÅömainMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  62          
  63          static Menu  curMenu;                                                           //ÊåáÂêëÂΩìÂâçËèúÂçïÁöÑËÆ∞ÂΩï
  64          static char curOp;                                                                      //ÂΩìÂâçÊù°ÁõÆ
  65          
  66          static bit isExit;                                                                      //Ê∂àÊÅØÂèòÈáèÔºöÊòØÂê¶ÈÄÄÂá∫ËèúÂçï
  67          
  68          extern bit   isSieveOn;                                                         //Ê∂àÊÅØÂèòÈáè:Á≠õÈÄâÊòØÂê¶ÊâìÂºÄ
  69          extern float sieveRVal;                                                         //Á≠õÈÄâÁîµÈòªÁöÑ‰∏≠ÂøÉÂÄº
  70          extern float errTolr;                                                           //ËØØÂ∑ÆÈôê
  71          extern bit   isDebug;                                                           //Ê∂àÊÅØÂèòÈáè:Ë∞ÉËØïÊ®°ÂºèÊâìÂºÄ
  72          
  73          sbit    Led1 = P1^0;                                                            //LedÂèòÈáè
  74          sbit    Led2 = P1^1;
  75          sbit    Led3 = P1^2;
  76          
  77          extern bit isKeyEvents;
  78          extern bit isTimerEvent;
  79          
  80          extern uchar key1Events;
  81          extern uchar key2Events;
  82          extern uchar key3Events;
  83          
  84          static uint  rNumPart;                                                          //Á≠õÈÄâÁîµÈòªÁöÑ‰∏â‰ΩçÊï∞Â≠óÈÉ®ÂàÜ
  85          static uchar rUnit;                                                                     //Á≠õÈÄâÁîµÈòªÁöÑÂçï‰ΩçÔºåÂèØ‰ª•ÊòØ 0x20 'K' 'M'
  86          static uchar errTolrE2;                                                         //ËØØÂ∑ÆÈôê*100
  87          /**
  88           * ÂàùÂßãÂåñËèúÂçï
  89           * @Author   Xiaobo     Yang
  90           * @DateTime 2018-07-21
  91           * @Summury
  92           */
  93          void InitialMenu(){
  94   1              debugYNMenu->superMenu=mainMenu;                                //ËèúÂçïÂâçÂêé‰∫íÊåáÔºåÂõ†Ê≠§‰∏ÄÈÉ®ÂàÜÊåáÂêëÂ∑•‰ΩúË¶ÅÂà∞Á®ãÂ∫èÂÆåÊàê
  95   1              sieveYNMenu->superMenu=mainMenu;
  96   1              curMenu=mainMenu;                                                               //ÂàùÂßãÂåñÊâÄÊúâÊúâÂÖ≥ÂÖ®Â±ÄÂèòÈáè
  97   1              curOp=0;
  98   1              isExit=0;
  99   1              isSieveOn=0;
 100   1              sieveRVal=0.0;
 101   1              errTolr=0.0;
 102   1              rNumPart=0;
 103   1              rUnit=0x20;
 104   1              errTolrE2=0;
 105   1              isDebug=1;
 106   1      }
 107          /**
 108           * ÊâìÂºÄËèúÂçï
 109           * @Author   Xiaobo     Yang
 110           * @DateTime 2018-07-21
 111           * @Summury
 112           */
 113          void MenuImpl(){
C51 COMPILER V9.01   MENU                                                                  07/21/2018 23:28:03 PAGE 3   

 114   1              curMenu=mainMenu;                                                               //‰ªéÂ§¥ÂºÄÂßãÊòæÁ§∫ËèúÂçï
 115   1              curOp=0;
 116   1              isExit=0;
 117   1              ShowMenu();
 118   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);                              //ÂºÄÂßãÈîÆÁõòÊâ´Êèè
 119   1              StartTimer();
 120   1              while(!isExit){
 121   2                      if(isKeyEvents){
 122   3                              SwitchTimerFun(TIMERFUN_HALT);                  //TODO:ÊàñËÆ∏ÂèØ‰ª•‰ºòÂåñÊéâ
 123   3                              MenuKeyTreat();
 124   3                              SwitchTimerFun(TIMERFUN_KEY_SCAN);              //ÈáçÂêØÈîÆÁõòÊâ´Êèè
 125   3                              StartTimer();
 126   3                      }
 127   2              }
 128   1      }
 129          /**
 130           * ÊòæÁ§∫ËèúÂçï
 131           * @Author   Xiaobo     Yang
 132           * @DateTime 2018-07-21
 133           * @Summury
 134           */
 135          void ShowMenu(){
 136   1              LCDCls();
 137   1              if(curOp!=0){
 138   2                      LCDMoveCursor(1,0);                                                                             //Ê≠§Â§ÑÊúâËé´ÂêçÂÖ∂Â¶ôÁöÑbugÔºåÈúÄË¶Å‰∏ìÈó®ÈáçËÆæÂÖâÊ†á
 139   2                      LCDPrintStr(1,0,curMenu->OpArray[curOp-1].opString);
 140   2                      LCDPrintStr(1,1,curMenu->OpArray[curOp].opString);
 141   2                      LCDPrintChar(0,1,'>');
 142   2              }
 143   1              else{
 144   2                      LCDMoveCursor(1,0);
 145   2                      LCDPrintStr(1,0,curMenu->OpArray[curOp].opString);
 146   2                      LCDPrintStr(1,1,curMenu->OpArray[curOp+1].opString);
 147   2                      LCDPrintChar(0,0,'>');
 148   2              }
 149   1      }
 150          /**
 151           * Â§ÑÁêÜËèúÂçïÊ®°Âºè‰∏ãÁöÑÊåâÈîÆ‰ø°ÊÅØ
 152           * @Author   Xiaobo     Yang
 153           * @DateTime 2018-07-21
 154           * @Summury
 155           */
 156          void MenuKeyTreat(){
 157   1              if(key1Events){                                                                                 //key1‰ºòÂÖàÁ∫ß>key2‰ºòÂÖàÁ∫ß>key3‰ºòÂÖàÁ∫ß
 158   2                      switch(key1Events){
 159   3                              case SHORT_PRESS:
 160   3                                      curOp=(++curOp)%(curMenu->opNum);                       //Âêë‰∏ãÈÄâÊã©
 161   3                                      ShowMenu();
 162   3                                      break;
 163   3                              case LONG_PRESS:
 164   3                                      curOp=curMenu->opNum-1;
 165   3                                      ShowMenu();
 166   3                                      break;
 167   3                      }
 168   2              }
 169   1              else if(key2Events){
 170   2                      switch(key2Events){
 171   3                              case SHORT_PRESS:                                                               //Âêë‰∏äÈÄâÊã©
 172   3                                      curOp=((--curOp)<0?curOp+(curMenu->opNum):curOp);       
 173   3                                      ShowMenu();
 174   3                                      break;
 175   3                              case LONG_PRESS:
C51 COMPILER V9.01   MENU                                                                  07/21/2018 23:28:03 PAGE 4   

 176   3                                      curOp=0;
 177   3                                      ShowMenu();
 178   3                                      break;
 179   3                      }
 180   2              }
 181   1              else{
 182   2                      switch(key3Events){
 183   3                              case SHORT_PRESS:
 184   3                              if(curMenu->OpArray[curOp].subMenu!=NULL){
 185   4                                      curMenu=curMenu->OpArray[curOp].subMenu;        //ËøõÂÖ•Â≠êËèúÂçï
 186   4                                      curOp=0;
 187   4                                      ShowMenu();
 188   4                              }
 189   3                              else{
 190   4                                      KeyInitial();                                                           //ÂàùÂßãÂåñÂ§ñËÆæÔºåÊó∂ÈíüÂ∑≤ÁªèÂú®MenuImpl‰∏≠ÂÅúÊ≠¢
 191   4                                      isExit=1;                                                                       //ËÆæÂÆöÈÄÄÂá∫Ê®°Âºè
 192   4                                      (*(curMenu->OpArray[curOp].pOpFunc)) ();        //ÊâßË°åÈÄâÈ°πÁöÑÂáΩÊï∞
 193   4                              }       
 194   3                                      break;
 195   3                              case LONG_PRESS:                                                                //ÈïøÊåâÂèØ‰ª•ÂõûÂà∞‰∏äÁ∫ßËèúÂçï
 196   3                                      if(curMenu->superMenu!=NULL){
 197   4                                              curMenu=curMenu->superMenu;
 198   4                                              curOp=0;
 199   4                                              ShowMenu();
 200   4                                      }
 201   3                                      break;
 202   3                              default:
 203   3                                      break;
 204   3                      }
 205   2              }
 206   1              RstKeyEvents();
 207   1      }
 208          /**
 209           * ‰ªÄ‰πàÈÉΩ‰∏çÂÅö
 210           * @Author   Xiaobo     Yang
 211           * @DateTime 2018-07-21
 212           * @Summury
 213           */
 214          void MenuOpExit(){
 215   1              return;
 216   1      }
 217          /**
 218           * Âà©Áî®IAP_CONTRËøõË°åËΩØ‰ª∂Â§ç‰Ωç
 219           * @Author   Xiaobo     Yang
 220           * @DateTime 2018-07-21
 221           * @Summury
 222           */
 223          void MenuOpRstDev(){
 224   1              uint i=3000;
 225   1              Led3=Led2=Led1=0;                                                                               //ÁÅ≠ÁÅØÔºåÁ≠âÂæÖÊøÄÂä®‰∫∫ÂøÉÁöÑ‰∏ÄÂàª
 226   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);
 227   1              StartTimer();
 228   1              while(i){
 229   2                      if(isTimerEvent){
 230   3                              isTimerEvent=0;
 231   3                              i--;                                                                                    //ÊØè0.5msËÆ©iÂáè‰∏ÄÔºå0.5S‰∫Æ‰∏Ä‰∏™ÁÅØ
 232   3                              if(i==2000){
 233   4                                      Led3=1;
 234   4                              }
 235   3                              else if(i==1000){
 236   4                                      Led2=1;
 237   4                              }
C51 COMPILER V9.01   MENU                                                                  07/21/2018 23:28:03 PAGE 5   

 238   3                      }
 239   2                      if(isKeyEvents){                                                                        //Â¶ÇÊúâÈîÆÁõò‰∫ã‰ª∂ÔºåÁ´ãÂç≥‰∏≠Êñ≠ÂáΩÊï∞ÊâßË°å
 240   3                              Led3=Led2=0;
 241   3                              return;
 242   3                      }
 243   2              }
 244   1              Led1=1;
 245   1              delaynms(500);
 246   1              ISP_CONTR=0x60;                                                                                 //ËΩØ‰ª∂Â§ç‰Ωç
 247   1      }
 248          /**
 249           * YNËèúÂçïÊâßË°åÔºåÁî®‰∫éÊîπÂèòdebugÂíåsieveÊ®°Âºè
 250           * @Author   Xiaobo     Yang
 251           * @DateTime 2018-07-21
 252           * @Summury
 253           */
 254          void MenuOpYN(){
 255   1              switch(curMenu->OpArray[curOp].opID){
 256   2                      case MENUID_DEBUG_YES:
 257   2                              isDebug=1;
 258   2                              break;
 259   2                      case MENUID_DEBUG_NO:
 260   2                              isDebug=0;
 261   2                              break;
 262   2                      case MENUID_SIEVE_YES:
 263   2                              isSieveOn=1;
 264   2                              break;
 265   2                      case MENUID_SIEVE_NO:
 266   2                              isSieveOn=0;
 267   2                              break;
 268   2              }
 269   1      }
 270          /**
 271           * ËΩ¨Âä®ËàµÊú∫ÁîªÊõ≤Á∫ø
 272           * @Author   Xiaobo     Yang
 273           * @DateTime 2018-07-21
 274           * @Summury
 275           */
 276          void MenuOpStartPlot(){
 277   1              //////////////////////
 278   1              //TODO:NOT FINISHED //
 279   1              //////////////////////
 280   1              return;
 281   1      }
 282          /**
 283           * ËÆæÁΩÆÁ≠õÈÄâÊù°‰ª∂
 284           * @Author   Xiaobo     Yang
 285           * @DateTime 2018-07-21
 286           * @Summury
 287           */
 288          void MenuOpSetSieve (){
 289   1              uchar curDigit=0;
 290   1              uchar isBreak=0;
 291   1              LCDCls();
 292   1              LCDPrintNumFixdgt(0,0,rNumPart,3);
 293   1              LCDPrintChar(3,0,rUnit);
 294   1              LCDPrintChar(curDigit,1,'^');
 295   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);
 296   1              StartTimer();
 297   1              while(!isBreak){
 298   2                      if(isKeyEvents){
 299   3                              if(key1Events){
C51 COMPILER V9.01   MENU                                                                  07/21/2018 23:28:03 PAGE 6   

 300   4                                      switch(key1Events){
 301   5                                              case SHORT_PRESS:
 302   5                                                      switch(curDigit){
 303   6                                                              case 0:
 304   6                                                                      rNumPart=(rNumPart+100)%1000;
 305   6                                                                      break;
 306   6                                                              case 1:
 307   6                                                                      rNumPart=(rNumPart+10)%1000;
 308   6                                                                      break;
 309   6                                                              case 2:
 310   6                                                                      rNumPart=(rNumPart+1)%1000;
 311   6                                                                      break;
 312   6                                                              case 3:
 313   6                                                                      switch(rUnit){
 314   7                                                                              case 0x20:
 315   7                                                                                      rUnit='K';
 316   7                                                                                      break;
 317   7                                                                              case 'K':
 318   7                                                                                      rUnit='M';
 319   7                                                                                      break;
 320   7                                                                              case 'M':
 321   7                                                                                      rUnit=0x20;
 322   7                                                                                      break;
 323   7                                                                      }
 324   6                                                              break;
 325   6                                                      }
 326   5                                                      break;
 327   5                                              case LONG_PRESS:
 328   5                                                      switch(curDigit){
 329   6                                                              case 0:
 330   6                                                                      rNumPart%=100;
 331   6                                                                      break;
 332   6                                                              case 1:
 333   6                                                                      rNumPart-=((rNumPart%100)/10)*10;
 334   6                                                                      break;
 335   6                                                              case 2:
 336   6                                                                      rNumPart-=rNumPart%10;
 337   6                                                                      break;
 338   6                                                              case 3:
 339   6                                                                      rUnit=0x20;
 340   6                                                                      break;
 341   6                                                      }
 342   5                                                      break;
 343   5                                      }
 344   4                                      LCDPrintNumFixdgt(0,0,rNumPart,3);
 345   4                                      LCDPrintChar(3,0,rUnit);
 346   4                              }
 347   3                              else if(key2Events){
 348   4                                      LCDPrintChar(curDigit,1,0x20);
 349   4                                      switch(key2Events){
 350   5                                              case SHORT_PRESS:
 351   5                                                      curDigit=++curDigit%4;
 352   5                                                      break;
 353   5                                              case LONG_PRESS:
 354   5                                                      if(curDigit==3){
 355   6                                                              curDigit=0;
 356   6                                                      }
 357   5                                                      else{
 358   6                                                              curDigit=3;
 359   6                                                      }
 360   5                                                      break;
 361   5                                      }
C51 COMPILER V9.01   MENU                                                                  07/21/2018 23:28:03 PAGE 7   

 362   4                                      LCDPrintChar(curDigit,1,'^');
 363   4                              }
 364   3                              else{
 365   4                                      switch(key3Events){
 366   5                                              case SHORT_PRESS:
 367   5                                                      isBreak=1;
 368   5                                                      break;
 369   5                                              default:
 370   5                                                      break;
 371   5                                      }
 372   4                              }
 373   3                              RstKeyEvents(); 
 374   3                      }
 375   2              }
 376   1              curDigit=0;
 377   1              isBreak=0;
 378   1              LCDCls();
 379   1              LCDPrintNumFixdgt(0,0,errTolrE2,2);
 380   1              LCDPrintChar(2,0,'%');
 381   1              LCDPrintChar(curDigit,1,'^');
 382   1              while(!isBreak){
 383   2                      if(isKeyEvents){
 384   3                              if(key1Events){
 385   4                                      switch(key1Events){
 386   5                                              case SHORT_PRESS:
 387   5                                                      switch(curDigit){
 388   6                                                              case 0:
 389   6                                                                      errTolrE2=(errTolrE2+10)%100;
 390   6                                                                      break;
 391   6                                                              case 1:
 392   6                                                                      errTolrE2=(++errTolrE2)%100;
 393   6                                                                      break;
 394   6                                                      }
 395   5                                                      break;
 396   5                                              case LONG_PRESS:
 397   5                                                      switch(curDigit){
 398   6                                                              case 0:
 399   6                                                                      errTolrE2%=10;
 400   6                                                                      break;
 401   6                                                              case 1:
 402   6                                                                      errTolrE2-=errTolrE2%10;
 403   6                                                                      break;
 404   6                                                      }
 405   5                                                      break;
 406   5                                      }
 407   4                                      LCDPrintNumFixdgt(0,0,errTolrE2,2);
 408   4                              }
 409   3                              else if(key2Events){
 410   4                                      LCDPrintChar(curDigit,1,0x20);
 411   4                                      switch(key2Events){
 412   5                                              case SHORT_PRESS:
 413   5                                                      curDigit=(++curDigit)%2;
 414   5                                                      break;
 415   5                                              case LONG_PRESS:
 416   5                                                      curDigit=0;
 417   5                                                      break;
 418   5                                      }
 419   4                                      LCDPrintChar(curDigit,1,'^');
 420   4                              }
 421   3                              else{
 422   4                                      switch(key3Events){
 423   5                                              case SHORT_PRESS:
C51 COMPILER V9.01   MENU                                                                  07/21/2018 23:28:03 PAGE 8   

 424   5                                                      isBreak=1;
 425   5                                                      break;
 426   5                                              default:
 427   5                                                      break;
 428   5                                      }
 429   4                              }
 430   3                              RstKeyEvents();
 431   3                      }
 432   2              }
 433   1              switch(rUnit){
 434   2                      case 0x20:
 435   2                              sieveRVal=rNumPart;
 436   2                              break;
 437   2                      case 'K':
 438   2                              sieveRVal=rNumPart*1e3;
 439   2                              break;
 440   2                      case 'M':
 441   2                              sieveRVal=rNumPart*1e6;
 442   2                              break;
 443   2              }
 444   1              errTolr=(float) errTolrE2/100.0;
 445   1              LCDCls();
 446   1              LCDPrintNumFixdgt(0,0,rNumPart,3);
 447   1              LCDPrintChar(3,0,rUnit);
 448   1              LCDPrintNumFixdgt(0,1,errTolrE2,2);
 449   1              LCDPrintFloat(8,0,sieveRVal);
 450   1              LCDPrintFloat(8,1,errTolr);
 451   1              delaynms(3000);
 452   1      }
 453          
 454          
 455          
 456          
 457          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1550    ----
   CONSTANT SIZE    =    190    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     22       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
