C51 COMPILER V9.01   MENU                                                                  07/22/2018 16:28:23 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MENU
OBJECT MODULE PLACED IN .\Menu.obj
COMPILER INVOKED BY: D:\Kell\C51\BIN\C51.EXE ..\Src\Menu.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Menu.lst) OBJECT(.\Menu.obj
                    -)

line level    source

   1          #include "RM.h"
   2          #include "Menu.h"
   3          #include "Timer.h"
   4          #include "Key.h"
   5          #include "LCD1602.h"
   6          #include "CalcR.h"
   7          
   8          #define MENUID_DEBUG_MODE_ON    0                                       //ËèúÂçïÈÄâÈ°πIDÁöÑÂÆèÂÆö‰πâ
   9          #define MENUID_SIEVE_MODE_ON    1
  10          #define MENUID_SET_SIEVE        3
  11          #define MENUID_START_PLOT       4
  12          #define MENUID_RESET_DEVICE     5
  13          #define MENUID_EXIT             6
  14          #define MENUID_DEBUG_YES                7
  15          #define MENUID_DEBUG_NO                 8
  16          #define MENUID_SIEVE_YES        9               
  17          #define MENUID_SIEVE_NO                 10      
  18          #define MENUID_AVERGE_YES       11
  19          #define MENUID_AVERGE_NO                12
  20          #define MENUID_AVERG_MODE_ON    13      
  21          
  22          #define MENU_OPTION_NUM_MAIN    7                                       //ËèúÂçïÊù°ÁõÆÊï∞ÁöÑÂÆèÂÆö‰πâ
  23          #define MENU_OPTION_NUM_YN              2
  24          
  25          typedef struct MenuRecord *ptrToMenuRecord;                     //ÂÆö‰πâÊåáÂêëËèúÂçïËÆ∞ÂΩïÁöÑÊåáÈíà
  26          typedef ptrToMenuRecord   Menu;                                         //ÊåáÂêëËèúÂçïËÆ∞ÂΩïÁöÑÊåáÈíàÁõ¥Êé•Âè´Menu
  27          typedef struct MenuOp     *ptrToMenuOp;                         //ÊåáÂêëËèúÂçïÈÄâÈ°πÁöÑÊåáÈíà
  28          
  29          struct MenuOp{                                                                          //ËèúÂçïÈÄâÈ°πÁöÑÁªìÊûÑ
  30                  uchar opID;                                                                             //ÈÄâÈ°πÁöÑID
  31                  char *opString;                                                                 //ÈÄâÈ°πÊòæÁ§∫ÁöÑÂ≠óÁ¨¶‰∏≤
  32                  Menu subMenu;                                                                   //ÈÄâÈ°πÁöÑÂ≠êËèúÂçï
  33                  void (*pOpFunc) (void);                                                 //ÈÄâÊã©ËØ•ÈÄâÈ°πÊâßË°åÁöÑÂáΩÊï∞
  34          };
  35          
  36          struct MenuRecord{                                                                      //ËèúÂçïËÆ∞ÂΩïÁöÑÁªìÊûÑ
  37                  uchar opNum;                                                                    //ËØ•ËèúÂçïÈÄâÈ°πÁöÑÊù°ÁõÆÊï∞
  38                  Menu superMenu;                                                                 //ËØ•ËèúÂçïÁöÑ‰∏ä‰∏ÄÁ∫ßËèúÂçï
  39                  ptrToMenuOp OpArray;                                                    //ËØ•ËèúÂçïÁöÑÊù°ÁõÆÊï∞ÁªÑ
  40          };
  41          
  42          static code struct MenuOp debugYNOpArray[MENU_OPTION_NUM_YN]={                                                          //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  43                  {MENUID_DEBUG_YES,"Yes",NULL,MenuOpYN},
  44                  {MENUID_DEBUG_NO,"No",NULL,MenuOpYN}
  45          };
  46          static struct MenuRecord debugYNMenuRecord={MENU_OPTION_NUM_YN,NULL,debugYNOpArray};            //Yes No  ËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  47          static code Menu debugYNMenu=&debugYNMenuRecord;                                                                                        //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  48          
  49          static code struct MenuOp sieveYNOpArray[MENU_OPTION_NUM_YN]={                                                          //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  50                  {MENUID_SIEVE_YES,"Yes",NULL,MenuOpYN},
  51                  {MENUID_SIEVE_NO,"No",NULL,MenuOpYN}
  52          };
  53          static struct MenuRecord sieveYNMenuRecord={MENU_OPTION_NUM_YN,NULL,sieveYNOpArray};            //Yes No  ËèúÂçïÁöÑË
C51 COMPILER V9.01   MENU                                                                  07/22/2018 16:28:23 PAGE 2   

             -èúÂçïËÆ∞ÂΩï
  54          static code Menu sieveYNMenu=&sieveYNMenuRecord;                                                                                        //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  55          
  56          static code struct MenuOp avergYNOpArray[MENU_OPTION_NUM_YN]={                                                          //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  57                  {MENUID_AVERGE_YES,"Yes",NULL,MenuOpYN},
  58                  {MENUID_AVERGE_NO,"No",NULL,MenuOpYN}
  59          };
  60          static struct MenuRecord avergYNMenuRecord={MENU_OPTION_NUM_YN,NULL,avergYNOpArray};            //Yes No  ËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  61          static code Menu avergYNMenu=&avergYNMenuRecord;                                                                                        //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  62          
  63          static code struct MenuOp MainMenuOpArray[MENU_OPTION_NUM_MAIN]={                                                       //mainËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ                             
  64                  {MENUID_DEBUG_MODE_ON,"Debug Mode On",&debugYNMenuRecord,NULL},
  65                  {MENUID_AVERG_MODE_ON,"Averg Mode On",&avergYNMenuRecord,NULL},
  66                  {MENUID_SIEVE_MODE_ON,"Sieve Mode On",&sieveYNMenuRecord,NULL},
  67                  {MENUID_SET_SIEVE,"Set Sieve",NULL,MenuOpSetSieve},
  68                  {MENUID_START_PLOT,"Start Plot",NULL,MenuOpStartPlot},
  69                  {MENUID_RESET_DEVICE,"Reset Device",NULL,MenuOpRstDev},
  70                  {MENUID_EXIT,"Exit",NULL,MenuOpExit}
  71          };
  72          static code struct MenuRecord mainMenuRecord={MENU_OPTION_NUM_MAIN,NULL,MainMenuOpArray};       //mainËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  73          static code Menu mainMenu=&mainMenuRecord;                                                                                                  //Áî®Âè´ÂÅömainMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  74          
  75          static Menu  curMenu;                                                           //ÊåáÂêëÂΩìÂâçËèúÂçïÁöÑËÆ∞ÂΩï
  76          static char curOp;                                                                      //ÂΩìÂâçÊù°ÁõÆ
  77          
  78          static bit isExit;                                                                      //Ê∂àÊÅØÂèòÈáèÔºöÊòØÂê¶ÈÄÄÂá∫ËèúÂçï
  79          
  80          extern bit   isSieveOn;                                                         //Ê∂àÊÅØÂèòÈáè:Á≠õÈÄâÊòØÂê¶ÊâìÂºÄ
  81          extern float sieveRVal;                                                         //Á≠õÈÄâÁîµÈòªÁöÑ‰∏≠ÂøÉÂÄº
  82          extern float errTolr;                                                           //ËØØÂ∑ÆÈôê
  83          extern bit   isDebug;                                                           //Ê∂àÊÅØÂèòÈáè:Ë∞ÉËØïÊ®°ÂºèÊâìÂºÄ
  84          extern bit   isAverg;
  85          
  86          sbit    Led1 = P1^0;                                                            //LedÂèòÈáè
  87          sbit    Led2 = P1^1;
  88          sbit    Led3 = P1^2;
  89          
  90          sbit servoConOut = P3^7;
  91          
  92          static uchar pwmTCount;                         
  93          static uchar pwmNCount;                         
  94          static xdata float pwmRVal[17]; 
  95          
  96          sbit  capSel=P3^7;
  97          extern float idata curRValue;
  98          extern code char *mearsStr;
  99          code char *disconnectStr="Disconnect P37";
 100          code char *connectStr="Connect P37";
 101          
 102          extern uchar t1IntrTimes;               
 103          extern bit isKeyEvents;
 104          extern bit isTimerEvent;
 105          extern unsigned long idata curN;
 106          
 107          extern uchar key1Events;
 108          extern uchar key2Events;
 109          extern uchar key3Events;
 110          
 111          static uint  rNumPart;                                                          //Á≠õÈÄâÁîµÈòªÁöÑ‰∏â‰ΩçÊï∞Â≠óÈÉ®ÂàÜ
 112          static uchar rUnit;                                                                     //Á≠õÈÄâÁîµÈòªÁöÑÂçï‰ΩçÔºåÂèØ‰ª•ÊòØ 0x20 'K' 'M'
C51 COMPILER V9.01   MENU                                                                  07/22/2018 16:28:23 PAGE 3   

 113          static uchar errTolrE2;                                                         //ËØØÂ∑ÆÈôê*100
 114          /**
 115           * ÂàùÂßãÂåñËèúÂçï
 116           * @Author   Xiaobo     Yang
 117           * @DateTime 2018-07-21
 118           * @Summury
 119           */
 120          void InitialMenu(){
 121   1              debugYNMenu->superMenu=mainMenu;                                //ËèúÂçïÂâçÂêé‰∫íÊåáÔºåÂõ†Ê≠§‰∏ÄÈÉ®ÂàÜÊåáÂêëÂ∑•‰ΩúË¶ÅÂà∞Á®ãÂ∫èÂÆåÊàê
 122   1              sieveYNMenu->superMenu=mainMenu;
 123   1              avergYNMenu->superMenu=mainMenu;
 124   1              curMenu=mainMenu;                                                               //ÂàùÂßãÂåñÊâÄÊúâÊúâÂÖ≥ÂÖ®Â±ÄÂèòÈáè
 125   1              curOp=0;
 126   1              isExit=0;
 127   1              isSieveOn=0;
 128   1              sieveRVal=0.0;
 129   1              errTolr=0.0;
 130   1              rNumPart=0;
 131   1              rUnit=0x20;
 132   1              errTolrE2=0;
 133   1              isDebug=1;
 134   1              pwmTCount=0;
 135   1              pwmNCount=0;
 136   1      }
 137          /**
 138           * ÊâìÂºÄËèúÂçï
 139           * @Author   Xiaobo     Yang
 140           * @DateTime 2018-07-21
 141           * @Summury
 142           */
 143          void MenuImpl(){
 144   1              curMenu=mainMenu;                                                               //‰ªéÂ§¥ÂºÄÂßãÊòæÁ§∫ËèúÂçï
 145   1              curOp=0;
 146   1              isExit=0;
 147   1              ShowMenu();
 148   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);                              //ÂºÄÂßãÈîÆÁõòÊâ´Êèè
 149   1              StartTimer();
 150   1              while(!isExit){
 151   2                      if(isKeyEvents){
 152   3                              SwitchTimerFun(TIMERFUN_HALT);                  //TODO:ÊàñËÆ∏ÂèØ‰ª•‰ºòÂåñÊéâ
 153   3                              MenuKeyTreat();
 154   3                              SwitchTimerFun(TIMERFUN_KEY_SCAN);              //ÈáçÂêØÈîÆÁõòÊâ´Êèè
 155   3                              StartTimer();
 156   3                      }
 157   2              }
 158   1      }
 159          /**
 160           * ÊòæÁ§∫ËèúÂçï
 161           * @Author   Xiaobo     Yang
 162           * @DateTime 2018-07-21
 163           * @Summury
 164           */
 165          void ShowMenu(){
 166   1              LCDCls();
 167   1              if(curOp!=0){
 168   2                      LCDMoveCursor(1,0);                                                                             //Ê≠§Â§ÑÊúâËé´ÂêçÂÖ∂Â¶ôÁöÑbugÔºåÈúÄË¶Å‰∏ìÈó®ÈáçËÆæÂÖâÊ†á
 169   2                      LCDPrintStr(1,0,curMenu->OpArray[curOp-1].opString);
 170   2                      LCDPrintStr(1,1,curMenu->OpArray[curOp].opString);
 171   2                      LCDPrintChar(0,1,'>');
 172   2              }
 173   1              else{
 174   2                      LCDMoveCursor(1,0);
C51 COMPILER V9.01   MENU                                                                  07/22/2018 16:28:23 PAGE 4   

 175   2                      LCDPrintStr(1,0,curMenu->OpArray[curOp].opString);
 176   2                      LCDPrintStr(1,1,curMenu->OpArray[curOp+1].opString);
 177   2                      LCDPrintChar(0,0,'>');
 178   2              }
 179   1      }
 180          /**
 181           * Â§ÑÁêÜËèúÂçïÊ®°Âºè‰∏ãÁöÑÊåâÈîÆ‰ø°ÊÅØ
 182           * @Author   Xiaobo     Yang
 183           * @DateTime 2018-07-21
 184           * @Summury
 185           */
 186          void MenuKeyTreat(){
 187   1              if(key1Events){                                                                                 //key1‰ºòÂÖàÁ∫ß>key2‰ºòÂÖàÁ∫ß>key3‰ºòÂÖàÁ∫ß
 188   2                      switch(key1Events){
 189   3                              case SHORT_PRESS:
 190   3                                      curOp=(++curOp)%(curMenu->opNum);                       //Âêë‰∏ãÈÄâÊã©
 191   3                                      ShowMenu();
 192   3                                      break;
 193   3                              case LONG_PRESS:
 194   3                                      curOp=curMenu->opNum-1;
 195   3                                      ShowMenu();
 196   3                                      break;
 197   3                      }
 198   2              }
 199   1              else if(key2Events){
 200   2                      switch(key2Events){
 201   3                              case SHORT_PRESS:                                                               //Âêë‰∏äÈÄâÊã©
 202   3                                      curOp=((--curOp)<0?curOp+(curMenu->opNum):curOp);       
 203   3                                      ShowMenu();
 204   3                                      break;
 205   3                              case LONG_PRESS:
 206   3                                      curOp=0;
 207   3                                      ShowMenu();
 208   3                                      break;
 209   3                      }
 210   2              }
 211   1              else{
 212   2                      switch(key3Events){
 213   3                              case SHORT_PRESS:
 214   3                              if(curMenu->OpArray[curOp].subMenu!=NULL){
 215   4                                      curMenu=curMenu->OpArray[curOp].subMenu;        //ËøõÂÖ•Â≠êËèúÂçï
 216   4                                      curOp=0;
 217   4                                      ShowMenu();
 218   4                              }
 219   3                              else{
 220   4                                      KeyInitial();                                                           //ÂàùÂßãÂåñÂ§ñËÆæÔºåÊó∂ÈíüÂ∑≤ÁªèÂú®MenuImpl‰∏≠ÂÅúÊ≠¢
 221   4                                      isExit=1;                                                                       //ËÆæÂÆöÈÄÄÂá∫Ê®°Âºè
 222   4                                      (*(curMenu->OpArray[curOp].pOpFunc)) ();        //ÊâßË°åÈÄâÈ°πÁöÑÂáΩÊï∞
 223   4                              }       
 224   3                                      break;
 225   3                              case LONG_PRESS:                                                                //ÈïøÊåâÂèØ‰ª•ÂõûÂà∞‰∏äÁ∫ßËèúÂçï
 226   3                                      if(curMenu->superMenu!=NULL){
 227   4                                              curMenu=curMenu->superMenu;
 228   4                                              curOp=0;
 229   4                                              ShowMenu();
 230   4                                      }
 231   3                                      break;
 232   3                              default:
 233   3                                      break;
 234   3                      }
 235   2              }
 236   1              RstKeyEvents();
C51 COMPILER V9.01   MENU                                                                  07/22/2018 16:28:23 PAGE 5   

 237   1      }
 238          /**
 239           * ‰ªÄ‰πàÈÉΩ‰∏çÂÅö
 240           * @Author   Xiaobo     Yang
 241           * @DateTime 2018-07-21
 242           * @Summury
 243           */
 244          void MenuOpExit(){
 245   1              return;
 246   1      }
 247          /**
 248           * Âà©Áî®IAP_CONTRËøõË°åËΩØ‰ª∂Â§ç‰Ωç
 249           * @Author   Xiaobo     Yang
 250           * @DateTime 2018-07-21
 251           * @Summury
 252           */
 253          void MenuOpRstDev(){
 254   1              uint i=3000;
 255   1              Led3=Led2=Led1=0;                                                                               //ÁÅ≠ÁÅØÔºåÁ≠âÂæÖÊøÄÂä®‰∫∫ÂøÉÁöÑ‰∏ÄÂàª
 256   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);
 257   1              StartTimer();
 258   1              while(i){
 259   2                      if(isTimerEvent){
 260   3                              isTimerEvent=0;
 261   3                              i--;                                                                                    //ÊØè0.5msËÆ©iÂáè‰∏ÄÔºå0.5S‰∫Æ‰∏Ä‰∏™ÁÅØ
 262   3                              if(i==2000){
 263   4                                      Led3=1;
 264   4                              }
 265   3                              else if(i==1000){
 266   4                                      Led2=1;
 267   4                              }
 268   3                      }
 269   2                      if(isKeyEvents){                                                                        //Â¶ÇÊúâÈîÆÁõò‰∫ã‰ª∂ÔºåÁ´ãÂç≥‰∏≠Êñ≠ÂáΩÊï∞ÊâßË°å
 270   3                              Led3=Led2=0;
 271   3                              return;
 272   3                      }
 273   2              }
 274   1              Led1=1;
 275   1              delaynms(500);
 276   1              ISP_CONTR=0x60;                                                                                 //ËΩØ‰ª∂Â§ç‰Ωç
 277   1      }
 278          /**
 279           * YNËèúÂçïÊâßË°åÔºåÁî®‰∫éÊîπÂèòdebugÂíåsieveÊ®°Âºè
 280           * @Author   Xiaobo     Yang
 281           * @DateTime 2018-07-21
 282           * @Summury
 283           */
 284          void MenuOpYN(){
 285   1              switch(curMenu->OpArray[curOp].opID){
 286   2                      case MENUID_DEBUG_YES:
 287   2                              isDebug=1;
 288   2                              break;
 289   2                      case MENUID_DEBUG_NO:
 290   2                              isDebug=0;
 291   2                              break;
 292   2                      case MENUID_SIEVE_YES:
 293   2                              isSieveOn=1;
 294   2                              break;
 295   2                      case MENUID_SIEVE_NO:
 296   2                              isSieveOn=0;
 297   2                              break;
 298   2                      case MENUID_AVERGE_YES:
C51 COMPILER V9.01   MENU                                                                  07/22/2018 16:28:23 PAGE 6   

 299   2                              isAverg=1;
 300   2                              break;
 301   2                      case MENUID_AVERGE_NO:
 302   2                              isAverg=0;
 303   2                              break;
 304   2              }
 305   1      }
 306          /**
 307           * ËΩ¨Âä®ËàµÊú∫ÁîªÊõ≤Á∫ø
 308           * @Author   Xiaobo     Yang
 309           * @DateTime 2018-07-21
 310           * @Summury
 311           */
 312          void MenuOpStartPlot(){
 313   1              uchar curShow;
 314   1              uchar isBreak;
 315   1              LCDCls();
 316   1              capSel=CAPSEL_LOWR;
 317   1              delaynms(500);
 318   1              LCDPrintLine(0,0,disconnectStr);
 319   1              PressAnyKey();
 320   1      
 321   1              LCDPrintLine(0,0,mearsStr);
 322   1              pwmTCount=0;
 323   1              pwmNCount=0;
 324   1              SwitchTimerFun(TIMERFUN_PWM);
 325   1              StartTimer();
 326   1      
 327   1              if(capSel==CAPSEL_LOWR) Led1=1;
 328   1      
 329   1              while(1){
 330   2                      if(isTimerEvent){
 331   3                              if(pwmTCount==17){                                      
 332   4                                      break;
 333   4                              }
 334   3      
 335   3                              if(t1IntrTimes==201){                           
 336   4                                      ++pwmNCount;                                    
 337   4                                      t1IntrTimes=1;
 338   4                              }
 339   3                              if(t1IntrTimes<=7+pwmTCount)
 340   3                                      servoConOut=1;                                  
 341   3                              else
 342   3                                      servoConOut=0;
 343   3      
 344   3                              if(pwmNCount==50){
 345   4                                      servoConOut=0;
 346   4                                      pwmNCount=0;
 347   4                                      SwitchTimerFun(TIMERFUN_FREQ_MEASRURE);
 348   4                                      StartTimer();
 349   4                                      while(!isTimerEvent);
 350   4                                      GetRVal();                                              
 351   4                                      pwmRVal[pwmTCount++]=4.031e7F*(1.0F/curN)-1764.0F;      
 352   4                                      SwitchTimerFun(TIMERFUN_PWM);   
 353   4                                      StartTimer();                                   
 354   4                              }
 355   3                      }
 356   2              }
 357   1              curShow=0;
 358   1              isBreak=0;
 359   1              LCDCls();
 360   1              LCDPrintFloat(0,0,pwmRVal[curShow]);
C51 COMPILER V9.01   MENU                                                                  07/22/2018 16:28:23 PAGE 7   

 361   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);
 362   1              StartTimer();
 363   1              while(!isBreak){
 364   2                      if(isKeyEvents){
 365   3                              if(key1Events){
 366   4                                      switch(key1Events){
 367   5                                              case SHORT_PRESS:
 368   5                                                      curShow=(++curShow)%17;
 369   5                                                      break;
 370   5                                              case LONG_PRESS:
 371   5                                                      curShow=16;
 372   5                                                      break;
 373   5                                      }
 374   4                              }
 375   3                              else if(key2Events){
 376   4                                      switch(key2Events){
 377   5                                              case SHORT_PRESS:
 378   5                                                      curShow= (--curShow)<0?16:curShow;
 379   5                                                      break;
 380   5                                              case LONG_PRESS:
 381   5                                                      curShow=0;
 382   5                                                      break;
 383   5                                      }
 384   4                              }
 385   3                              else{
 386   4                                      switch(key3Events){
 387   5                                              case SHORT_PRESS:
 388   5                                                      isBreak=1;
 389   5                                                      break;
 390   5                                              default:
 391   5                                                      break;
 392   5                                      }
 393   4                              }
 394   3                              LCDCls();
 395   3                              LCDPrintFloat(0,0,pwmRVal[curShow]);
 396   3                              RstKeyEvents();
 397   3                      }
 398   2              }
 399   1              LCDPrintLine(0,0,connectStr);
 400   1              PressAnyKey();
 401   1              capSel=CAPSEL_LOWR;
 402   1              Led1=0;
 403   1              delaynms(500);
 404   1      }
 405          /**
 406           * ËÆæÁΩÆÁ≠õÈÄâÊù°‰ª∂
 407           * @Author   Xiaobo     Yang
 408           * @DateTime 2018-07-21
 409           * @Summury
 410           */
 411          void MenuOpSetSieve (){
 412   1              uchar curDigit=0;
 413   1              uchar isBreak=0;
 414   1              LCDCls();
 415   1              LCDPrintNumFixdgt(0,0,rNumPart,3);
 416   1              LCDPrintChar(3,0,rUnit);
 417   1              LCDPrintChar(curDigit,1,'^');
 418   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);
 419   1              StartTimer();
 420   1              while(!isBreak){
 421   2                      if(isKeyEvents){
 422   3                              if(key1Events){
C51 COMPILER V9.01   MENU                                                                  07/22/2018 16:28:23 PAGE 8   

 423   4                                      switch(key1Events){
 424   5                                              case SHORT_PRESS:
 425   5                                                      switch(curDigit){
 426   6                                                              case 0:
 427   6                                                                      rNumPart=(rNumPart+100)%1000;
 428   6                                                                      break;
 429   6                                                              case 1:
 430   6                                                                      rNumPart=(rNumPart+10)%1000;
 431   6                                                                      break;
 432   6                                                              case 2:
 433   6                                                                      rNumPart=(rNumPart+1)%1000;
 434   6                                                                      break;
 435   6                                                              case 3:
 436   6                                                                      switch(rUnit){
 437   7                                                                              case 0x20:
 438   7                                                                                      rUnit='K';
 439   7                                                                                      break;
 440   7                                                                              case 'K':
 441   7                                                                                      rUnit='M';
 442   7                                                                                      break;
 443   7                                                                              case 'M':
 444   7                                                                                      rUnit=0x20;
 445   7                                                                                      break;
 446   7                                                                      }
 447   6                                                              break;
 448   6                                                      }
 449   5                                                      break;
 450   5                                              case LONG_PRESS:
 451   5                                                      switch(curDigit){
 452   6                                                              case 0:
 453   6                                                                      rNumPart%=100;
 454   6                                                                      break;
 455   6                                                              case 1:
 456   6                                                                      rNumPart-=((rNumPart%100)/10)*10;
 457   6                                                                      break;
 458   6                                                              case 2:
 459   6                                                                      rNumPart-=rNumPart%10;
 460   6                                                                      break;
 461   6                                                              case 3:
 462   6                                                                      rUnit=0x20;
 463   6                                                                      break;
 464   6                                                      }
 465   5                                                      break;
 466   5                                      }
 467   4                                      LCDPrintNumFixdgt(0,0,rNumPart,3);
 468   4                                      LCDPrintChar(3,0,rUnit);
 469   4                              }
 470   3                              else if(key2Events){
 471   4                                      LCDPrintChar(curDigit,1,0x20);
 472   4                                      switch(key2Events){
 473   5                                              case SHORT_PRESS:
 474   5                                                      curDigit=++curDigit%4;
 475   5                                                      break;
 476   5                                              case LONG_PRESS:
 477   5                                                      if(curDigit==3){
 478   6                                                              curDigit=0;
 479   6                                                      }
 480   5                                                      else{
 481   6                                                              curDigit=3;
 482   6                                                      }
 483   5                                                      break;
 484   5                                      }
C51 COMPILER V9.01   MENU                                                                  07/22/2018 16:28:23 PAGE 9   

 485   4                                      LCDPrintChar(curDigit,1,'^');
 486   4                              }
 487   3                              else{
 488   4                                      switch(key3Events){
 489   5                                              case SHORT_PRESS:
 490   5                                                      isBreak=1;
 491   5                                                      break;
 492   5                                              default:
 493   5                                                      break;
 494   5                                      }
 495   4                              }
 496   3                              RstKeyEvents(); 
 497   3                      }
 498   2              }
 499   1              curDigit=0;
 500   1              isBreak=0;
 501   1              LCDCls();
 502   1              LCDPrintNumFixdgt(0,0,errTolrE2,2);
 503   1              LCDPrintChar(2,0,'%');
 504   1              LCDPrintChar(curDigit,1,'^');
 505   1              while(!isBreak){
 506   2                      if(isKeyEvents){
 507   3                              if(key1Events){
 508   4                                      switch(key1Events){
 509   5                                              case SHORT_PRESS:
 510   5                                                      switch(curDigit){
 511   6                                                              case 0:
 512   6                                                                      errTolrE2=(errTolrE2+10)%100;
 513   6                                                                      break;
 514   6                                                              case 1:
 515   6                                                                      errTolrE2=(++errTolrE2)%100;
 516   6                                                                      break;
 517   6                                                      }
 518   5                                                      break;
 519   5                                              case LONG_PRESS:
 520   5                                                      switch(curDigit){
 521   6                                                              case 0:
 522   6                                                                      errTolrE2%=10;
 523   6                                                                      break;
 524   6                                                              case 1:
 525   6                                                                      errTolrE2-=errTolrE2%10;
 526   6                                                                      break;
 527   6                                                      }
 528   5                                                      break;
 529   5                                      }
 530   4                                      LCDPrintNumFixdgt(0,0,errTolrE2,2);
 531   4                              }
 532   3                              else if(key2Events){
 533   4                                      LCDPrintChar(curDigit,1,0x20);
 534   4                                      switch(key2Events){
 535   5                                              case SHORT_PRESS:
 536   5                                                      curDigit=(++curDigit)%2;
 537   5                                                      break;
 538   5                                              case LONG_PRESS:
 539   5                                                      curDigit=0;
 540   5                                                      break;
 541   5                                      }
 542   4                                      LCDPrintChar(curDigit,1,'^');
 543   4                              }
 544   3                              else{
 545   4                                      switch(key3Events){
 546   5                                              case SHORT_PRESS:
C51 COMPILER V9.01   MENU                                                                  07/22/2018 16:28:23 PAGE 10  

 547   5                                                      isBreak=1;
 548   5                                                      break;
 549   5                                              default:
 550   5                                                      break;
 551   5                                      }
 552   4                              }
 553   3                              RstKeyEvents();
 554   3                      }
 555   2              }
 556   1              switch(rUnit){
 557   2                      case 0x20:
 558   2                              sieveRVal=rNumPart;
 559   2                              break;
 560   2                      case 'K':
 561   2                              sieveRVal=rNumPart*1e3;
 562   2                              break;
 563   2                      case 'M':
 564   2                              sieveRVal=rNumPart*1e6;
 565   2                              break;
 566   2              }
 567   1              errTolr=(float) errTolrE2/100.0;
 568   1              LCDCls();
 569   1              LCDPrintNumFixdgt(0,0,rNumPart,3);
 570   1              LCDPrintChar(3,0,rUnit);
 571   1              LCDPrintNumFixdgt(0,1,errTolrE2,2);
 572   1              LCDPrintFloat(8,0,sieveRVal);
 573   1              LCDPrintFloat(8,1,errTolr);
 574   1              delaynms(3000);
 575   1      }
 576          
 577          
 578          
 579          
 580          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2046    ----
   CONSTANT SIZE    =    270    ----
   XDATA SIZE       =     68    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     31       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
