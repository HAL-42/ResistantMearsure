C51 COMPILER V9.01   MENU                                                                  07/21/2018 21:48:23 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MENU
OBJECT MODULE PLACED IN .\Menu.obj
COMPILER INVOKED BY: D:\Kell\C51\BIN\C51.EXE ..\Src\Menu.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Menu.lst) OBJECT(.\Menu.obj
                    -)

line level    source

   1          #include "RM.h"
   2          #include "Menu.h"
   3          #include "Timer.h"
   4          #include "Key.h"
   5          #include "LCD1602.h"
   6          
   7          #define MENUID_DEBUG_MODE_ON    0                                       //ËèúÂçïÈÄâÈ°πIDÁöÑÂÆèÂÆö‰πâ
   8          #define MENUID_SIEVE_MODE_ON    1
   9          #define MENUID_SET_SIEVE        3
  10          #define MENUID_START_PLOT       4
  11          #define MENUID_RESET_DEVICE     5
  12          #define MENUID_EXIT             6
  13          #define MENUID_DEBUG_YES                7
  14          #define MENUID_DEBUG_NO                 8
  15          #define MENUID_SIEVE_YES        9               
  16          #define MENUID_SIEVE_NO                 10              
  17          
  18          #define MENU_OPTION_NUM_MAIN    6                                       //ËèúÂçïÊù°ÁõÆÊï∞ÁöÑÂÆèÂÆö‰πâ
  19          #define MENU_OPTION_NUM_YN              2
  20          
  21          typedef struct MenuRecord *ptrToMenuRecord;                     //ÂÆö‰πâÊåáÂêëËèúÂçïËÆ∞ÂΩïÁöÑÊåáÈíà
  22          typedef ptrToMenuRecord   Menu;                                         //ÊåáÂêëËèúÂçïËÆ∞ÂΩïÁöÑÊåáÈíàÁõ¥Êé•Âè´Menu
  23          typedef struct MenuOp     *ptrToMenuOp;                         //ÊåáÂêëËèúÂçïÈÄâÈ°πÁöÑÊåáÈíà
  24          
  25          struct MenuOp{                                                                          //ËèúÂçïÈÄâÈ°πÁöÑÁªìÊûÑ
  26                  uchar opID;                                                                             //ÈÄâÈ°πÁöÑID
  27                  char *opString;                                                                 //ÈÄâÈ°πÊòæÁ§∫ÁöÑÂ≠óÁ¨¶‰∏≤
  28                  Menu subMenu;                                                                   //ÈÄâÈ°πÁöÑÂ≠êËèúÂçï
  29                  void (*pOpFunc) (void);                                                 //ÈÄâÊã©ËØ•ÈÄâÈ°πÊâßË°åÁöÑÂáΩÊï∞
  30          };
  31          
  32          struct MenuRecord{                                                                      //ËèúÂçïËÆ∞ÂΩïÁöÑÁªìÊûÑ
  33                  uchar opNum;                                                                    //ËØ•ËèúÂçïÈÄâÈ°πÁöÑÊù°ÁõÆÊï∞
  34                  Menu superMenu;                                                                 //ËØ•ËèúÂçïÁöÑ‰∏ä‰∏ÄÁ∫ßËèúÂçï
  35                  ptrToMenuOp OpArray;                                                    //ËØ•ËèúÂçïÁöÑÊù°ÁõÆÊï∞ÁªÑ
  36          };
  37          
  38          static code struct MenuOp debugYNOpArray[MENU_OPTION_NUM_YN]={                                                          //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  39                  {MENUID_DEBUG_YES,"Yes",NULL,MenuOpYN},
  40                  {MENUID_DEBUG_NO,"No",NULL,MenuOpYN}
  41          };
  42          static struct MenuRecord debugYNMenuRecord={MENU_OPTION_NUM_YN,NULL,debugYNOpArray};            //Yes No  ËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  43          static code Menu debugYNMenu=&debugYNMenuRecord;                                                                                        //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  44          
  45          static code struct MenuOp sieveYNOpArray[MENU_OPTION_NUM_YN]={                                                          //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  46                  {MENUID_SIEVE_YES,"Yes",NULL,MenuOpYN},
  47                  {MENUID_SIEVE_NO,"No",NULL,MenuOpYN}
  48          };
  49          static struct MenuRecord sieveYNMenuRecord={MENU_OPTION_NUM_YN,NULL,sieveYNOpArray};            //Yes No  ËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  50          static code Menu sieveYNMenu=&sieveYNMenuRecord;                                                                                        //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  51          
  52          static code struct MenuOp MainMenuOpArray[MENU_OPTION_NUM_MAIN]={                                                       //mainËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ                             
C51 COMPILER V9.01   MENU                                                                  07/21/2018 21:48:23 PAGE 2   

  53                  {MENUID_DEBUG_MODE_ON,"Debug Mode On",&debugYNMenuRecord,NULL},
  54                  {MENUID_SIEVE_MODE_ON,"Sieve Mode On",&sieveYNMenuRecord,NULL},
  55                  {MENUID_SET_SIEVE,"Set Sieve",NULL,MenuOpSetSieve},
  56                  {MENUID_START_PLOT,"Start Plot",NULL,MenuOpStartPlot},
  57                  {MENUID_RESET_DEVICE,"Reset Device",NULL,MenuOpRstDev},
  58                  {MENUID_EXIT,"Exit",NULL,MenuOpExit}
  59          };
  60          static code struct MenuRecord mainMenuRecord={MENU_OPTION_NUM_MAIN,NULL,MainMenuOpArray};       //mainËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  61          static code Menu mainMenu=&mainMenuRecord;                                                                                                  //Áî®Âè´ÂÅömainMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  62          
  63          static Menu  curMenu;                                                           //ÊåáÂêëÂΩìÂâçËèúÂçïÁöÑËÆ∞ÂΩï
  64          static uchar curOp;                                                                     //ÂΩìÂâçÊù°ÁõÆ
  65          
  66          static bit isExit;                                                                      //Ê∂àÊÅØÂèòÈáèÔºöÊòØÂê¶ÈÄÄÂá∫ËèúÂçï
  67          
  68          extern bit   isSieveOn;                                                         //Ê∂àÊÅØÂèòÈáè:Á≠õÈÄâÊòØÂê¶ÊâìÂºÄ
  69          extern float sieveRVal;                                                         //Á≠õÈÄâÁîµÈòªÁöÑ‰∏≠ÂøÉÂÄº
  70          extern float errTolr;                                                           //ËØØÂ∑ÆÈôê
  71          extern bit   isDebug;                                                           //Ê∂àÊÅØÂèòÈáè:Ë∞ÉËØïÊ®°ÂºèÊâìÂºÄ
  72          
  73          sbit    Led1 = P1^0;                                                            //LedÂèòÈáè
  74          sbit    Led2 = P1^1;
  75          sbit    Led3 = P1^2;
  76          
  77          extern bit isKeyEvents;
  78          extern bit isTimerEvent;
  79          
  80          extern uchar key1Events;
  81          extern uchar key2Events;
  82          extern uchar key3Events;
  83          
  84          static uint  rNumPart;                                                          //Á≠õÈÄâÁîµÈòªÁöÑ‰∏â‰ΩçÊï∞Â≠óÈÉ®ÂàÜ
  85          static uchar rUnit;                                                                     //Á≠õÈÄâÁîµÈòªÁöÑÂçï‰ΩçÔºåÂèØ‰ª•ÊòØ 0x20 'K' 'M'
  86          static uchar errTolrE2;                                                         //ËØØÂ∑ÆÈôê*100
  87          /**
  88           * ÂàùÂßãÂåñËèúÂçï
  89           * @Author   Xiaobo     Yang
  90           * @DateTime 2018-07-21
  91           * @Summury
  92           */
  93          void InitialMenu(){
  94   1              debugYNMenu->superMenu=mainMenu;                                //ËèúÂçïÂâçÂêé‰∫íÊåáÔºåÂõ†Ê≠§‰∏ÄÈÉ®ÂàÜÊåáÂêëÂ∑•‰ΩúË¶ÅÂà∞Á®ãÂ∫èÂÆåÊàê
  95   1              sieveYNMenu->superMenu=mainMenu;
  96   1              curMenu=mainMenu;                                                               //ÂàùÂßãÂåñÊâÄÊúâÊúâÂÖ≥ÂÖ®Â±ÄÂèòÈáè
  97   1              curOp=0;
  98   1              isExit=0;
  99   1              isSieveOn=0;
 100   1              sieveRVal=0.0;
 101   1              errTolr=0.0;
 102   1              rNumPart=0;
 103   1              rUnit=0x20;
 104   1              errTolrE2=0;
 105   1              isDebug=1;
 106   1      }
 107          /**
 108           * ÊâìÂºÄËèúÂçï
 109           * @Author   Xiaobo     Yang
 110           * @DateTime 2018-07-21
 111           * @Summury
 112           */
 113          void MenuImpl(){
C51 COMPILER V9.01   MENU                                                                  07/21/2018 21:48:23 PAGE 3   

 114   1              curMenu=mainMenu;                                                               //‰ªéÂ§¥ÂºÄÂßãÊòæÁ§∫ËèúÂçï
 115   1              curOp=0;
 116   1              isExit=0;
 117   1              ShowMenu();
 118   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);                              //ÂºÄÂßãÈîÆÁõòÊâ´Êèè
 119   1              StartTimer();
 120   1              while(!isExit){
 121   2                      if(isKeyEvents){
 122   3                              SwitchTimerFun(TIMERFUN_HALT);                  //TODO:ÊàñËÆ∏ÂèØ‰ª•‰ºòÂåñÊéâ
 123   3                              MenuKeyTreat();
 124   3                              SwitchTimerFun(TIMERFUN_KEY_SCAN);              //ÈáçÂêØÈîÆÁõòÊâ´Êèè
 125   3                              StartTimer();
 126   3                      }
 127   2              }
 128   1      }
 129          /**
 130           * ÊòæÁ§∫ËèúÂçï
 131           * @Author   Xiaobo     Yang
 132           * @DateTime 2018-07-21
 133           * @Summury
 134           */
 135          void ShowMenu(){
 136   1              LCDCls();
 137   1              if(curOp!=0){
 138   2                      LCDMoveCursor(1,0);                                                                             //Ê≠§Â§ÑÊúâËé´ÂêçÂÖ∂Â¶ôÁöÑbugÔºåÈúÄË¶Å‰∏ìÈó®ÈáçËÆæÂÖâÊ†á
 139   2                      LCDPrintStr(1,0,curMenu->OpArray[curOp-1].opString);
 140   2                      LCDPrintStr(1,1,curMenu->OpArray[curOp].opString);
 141   2                      LCDPrintChar(0,1,'>');
 142   2              }
 143   1              else{
 144   2                      LCDMoveCursor(1,0);
 145   2                      LCDPrintStr(1,0,curMenu->OpArray[curOp].opString);
 146   2                      LCDPrintStr(1,1,curMenu->OpArray[curOp+1].opString);
 147   2                      LCDPrintChar(0,0,'>');
 148   2              }
 149   1      }
 150          /**
 151           * Â§ÑÁêÜËèúÂçïÊ®°Âºè‰∏ãÁöÑÊåâÈîÆ‰ø°ÊÅØ
 152           * @Author   Xiaobo     Yang
 153           * @DateTime 2018-07-21
 154           * @Summury
 155           */
 156          void MenuKeyTreat(){
 157   1              if(key1Events){                                                                                 //key1‰ºòÂÖàÁ∫ß>key2‰ºòÂÖàÁ∫ß>key3‰ºòÂÖàÁ∫ß
 158   2                      switch(key1Events){
 159   3                              case SHORT_PRESS:
 160   3                                      curOp=(++curOp)%(curMenu->opNum);                               //Âêë‰∏ãÈÄâÊã©
 161   3                                      if(curOp==1) Led1=1;
 162   3                                      ShowMenu();
 163   3                                      break;
 164   3                              case LONG_PRESS:
 165   3                                      curOp=curMenu->opNum-1;
 166   3                                      ShowMenu();
 167   3                                      break;
 168   3                      }
 169   2              }
 170   1              else if(key2Events){
 171   2                      switch(key2Events){
 172   3                              case SHORT_PRESS:
 173   3                                      curOp=(--curOp)%(curMenu->opNum);                               //Âêë‰∏äÈÄâÊã©
 174   3                                      ShowMenu();
 175   3                                      break;
C51 COMPILER V9.01   MENU                                                                  07/21/2018 21:48:23 PAGE 4   

 176   3                              case LONG_PRESS:
 177   3                                      curOp=0;
 178   3                                      ShowMenu();
 179   3                                      break;
 180   3                      }
 181   2              }
 182   1              else{
 183   2                      switch(key3Events){
 184   3                              case SHORT_PRESS:
 185   3                              if(curMenu->OpArray[curOp].subMenu!=NULL){
 186   4                                      curMenu=curMenu->OpArray[curOp].subMenu;        //ËøõÂÖ•Â≠êËèúÂçï
 187   4                                      curOp=0;
 188   4                                      ShowMenu();
 189   4                              }
 190   3                              else{
 191   4                                      KeyInitial();                                                           //ÂàùÂßãÂåñÂ§ñËÆæÔºåÊó∂ÈíüÂ∑≤ÁªèÂú®MenuImpl‰∏≠ÂÅúÊ≠¢
 192   4                                      isExit=1;                                                                       //ËÆæÂÆöÈÄÄÂá∫Ê®°Âºè
 193   4                                      (*(curMenu->OpArray[curOp].pOpFunc)) ();        //ÊâßË°åÈÄâÈ°πÁöÑÂáΩÊï∞
 194   4                              }       
 195   3                                      break;
 196   3                              case LONG_PRESS:                                                                //ÈïøÊåâÂèØ‰ª•ÂõûÂà∞‰∏äÁ∫ßËèúÂçï
 197   3                                      if(curMenu->superMenu!=NULL){
 198   4                                              curMenu=curMenu->superMenu;
 199   4                                              curOp=0;
 200   4                                              ShowMenu();
 201   4                                      }
 202   3                                      break;
 203   3                              default:
 204   3                                      break;
 205   3                      }
 206   2              }
 207   1              RstKeyEvents();
 208   1      }
 209          /**
 210           * ‰ªÄ‰πàÈÉΩ‰∏çÂÅö
 211           * @Author   Xiaobo     Yang
 212           * @DateTime 2018-07-21
 213           * @Summury
 214           */
 215          void MenuOpExit(){
 216   1              return;
 217   1      }
 218          /**
 219           * Âà©Áî®IAP_CONTRËøõË°åËΩØ‰ª∂Â§ç‰Ωç
 220           * @Author   Xiaobo     Yang
 221           * @DateTime 2018-07-21
 222           * @Summury
 223           */
 224          void MenuOpRstDev(){
 225   1              // uint i=6000;
 226   1              // Led3=Led2=Led1=0;                                                                            //ÁÅ≠ÁÅØÔºåÁ≠âÂæÖÊøÄÂä®‰∫∫ÂøÉÁöÑ‰∏ÄÂàª
 227   1              // LCDPrintScreen("Press Any Key To","Stop RESET!");
 228   1              // SwitchTimerFun(TIMERFUN_KEY_SCAN);
 229   1              // StartTimer();
 230   1              // while(i){
 231   1              //      if(isTimerEvent){
 232   1              //              isTimerEvent=0;
 233   1              //              i--;                                                                                    //ÊØè0.5msËÆ©iÂáè‰∏ÄÔºå1S‰∫Æ‰∏Ä‰∏™ÁÅØ
 234   1              //              if(i==4000){
 235   1              //                      Led3=1;
 236   1              //              }
 237   1              //              else if(i==2000){
C51 COMPILER V9.01   MENU                                                                  07/21/2018 21:48:23 PAGE 5   

 238   1              //                      Led2=1;
 239   1              //              }
 240   1              //      }
 241   1              //      if(isKeyEvents){                                                                        //Â¶ÇÊúâÈîÆÁõò‰∫ã‰ª∂ÔºåÁ´ãÂç≥‰∏≠Êñ≠ÂáΩÊï∞ÊâßË°å
 242   1              //              return;
 243   1              //      }
 244   1              // }
 245   1              // Led1=1;
 246   1              // delaynms(1000);
 247   1              // ISP_CONTR = 0x60;                                                                            //Â§ç‰Ωç
 248   1              return;
 249   1      }
 250          /**
 251           * YNËèúÂçïÊâßË°åÔºåÁî®‰∫éÊîπÂèòdebugÂíåsieveÊ®°Âºè
 252           * @Author   Xiaobo     Yang
 253           * @DateTime 2018-07-21
 254           * @Summury
 255           */
 256          void MenuOpYN(){
 257   1              switch(curMenu->OpArray[curOp].opID){
 258   2                      case MENUID_DEBUG_YES:
 259   2                              isDebug=1;
 260   2                              break;
 261   2                      case MENUID_DEBUG_NO:
 262   2                              isDebug=0;
 263   2                              break;
 264   2                      case MENUID_SIEVE_YES:
 265   2                              isSieveOn=1;
 266   2                              break;
 267   2                      case MENUID_SIEVE_NO:
 268   2                              isSieveOn=0;
 269   2                              break;
 270   2              }
 271   1      }
 272          /**
 273           * ËΩ¨Âä®ËàµÊú∫ÁîªÊõ≤Á∫ø
 274           * @Author   Xiaobo     Yang
 275           * @DateTime 2018-07-21
 276           * @Summury
 277           */
 278          void MenuOpStartPlot(){
 279   1              //////////////////////
 280   1              //TODO:NOT FINISHED //
 281   1              //////////////////////
 282   1              return;
 283   1      }
 284          /**
 285           * ËÆæÁΩÆÁ≠õÈÄâÊù°‰ª∂
 286           * @Author   Xiaobo     Yang
 287           * @DateTime 2018-07-21
 288           * @Summury
 289           */
 290          code void MenuOpSetSieve (){
 291   1              uchar curDigit=0;
 292   1              uchar isBreak=0;
 293   1              LCDCls();
 294   1              LCDPrintNumFixdgt(0,0,rNumPart,3);
 295   1              LCDPrintChar(3,0,rUnit);
 296   1              LCDPrintChar(curDigit,1,'^');
 297   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);
 298   1              StartTimer();
 299   1              while(!isBreak){
C51 COMPILER V9.01   MENU                                                                  07/21/2018 21:48:23 PAGE 6   

 300   2                      if(isKeyEvents){
 301   3                              if(key1Events){
 302   4                                      switch(key1Events){
 303   5                                              case SHORT_PRESS:
 304   5                                                      switch(curDigit){
 305   6                                                              case 0:
 306   6                                                                      rNumPart=(rNumPart+100)%1000;
 307   6                                                                      break;
 308   6                                                              case 1:
 309   6                                                                      rNumPart=(rNumPart+10)%1000;
 310   6                                                                      break;
 311   6                                                              case 2:
 312   6                                                                      rNumPart=(rNumPart+1)%1000;
 313   6                                                                      break;
 314   6                                                              case 3:
 315   6                                                                      switch(rUnit){
 316   7                                                                              case 0x20:
 317   7                                                                                      rUnit='K';
 318   7                                                                                      break;
 319   7                                                                              case 'K':
 320   7                                                                                      rUnit='M';
 321   7                                                                                      break;
 322   7                                                                              case 'M':
 323   7                                                                                      rUnit=0x20;
 324   7                                                                                      break;
 325   7                                                                      }
 326   6                                                              break;
 327   6                                                      }
 328   5                                                      break;
 329   5                                              case LONG_PRESS:
 330   5                                                      switch(curDigit){
 331   6                                                              case 0:
 332   6                                                                      rNumPart%=100;
 333   6                                                                      break;
 334   6                                                              case 1:
 335   6                                                                      rNumPart-=((rNumPart%100)/10)*10;
 336   6                                                                      break;
 337   6                                                              case 2:
 338   6                                                                      rNumPart-=rNumPart%10;
 339   6                                                                      break;
 340   6                                                              case 3:
 341   6                                                                      rUnit=0x20;
 342   6                                                                      break;
 343   6                                                      }
 344   5                                                      break;
 345   5                                      }
 346   4                                      LCDPrintNumFixdgt(0,0,rNumPart,3);
 347   4                                      LCDPrintChar(3,0,rUnit);
 348   4                              }
 349   3                              else if(key2Events){
 350   4                                      LCDPrintChar(curDigit,1,0x20);
 351   4                                      switch(key2Events){
 352   5                                              case SHORT_PRESS:
 353   5                                                      curDigit=++curDigit%4;
 354   5                                                      break;
 355   5                                              case LONG_PRESS:
 356   5                                                      if(curDigit==3){
 357   6                                                              curDigit=0;
 358   6                                                      }
 359   5                                                      else{
 360   6                                                              curDigit=3;
 361   6                                                      }
C51 COMPILER V9.01   MENU                                                                  07/21/2018 21:48:23 PAGE 7   

 362   5                                                      break;
 363   5                                      }
 364   4                                      LCDPrintChar(curDigit,1,'^');
 365   4                              }
 366   3                              else{
 367   4                                      switch(key3Events){
 368   5                                              case SHORT_PRESS:
 369   5                                                      isBreak=1;
 370   5                                                      break;
 371   5                                              default:
 372   5                                                      break;
 373   5                                      }
 374   4                              }
 375   3                              RstKeyEvents(); 
 376   3                      }
 377   2              }
 378   1              curDigit=0;
 379   1              isBreak=0;
 380   1              LCDCls();
 381   1              LCDPrintNumFixdgt(0,0,errTolrE2,2);
 382   1              LCDPrintChar(2,0,'%');
 383   1              LCDPrintChar(curDigit,1,'^');
 384   1              while(!isBreak){
 385   2                      if(isKeyEvents){
 386   3                              if(key1Events){
 387   4                                      switch(key1Events){
 388   5                                              case SHORT_PRESS:
 389   5                                                      switch(curDigit){
 390   6                                                              case 0:
 391   6                                                                      errTolrE2=(errTolrE2+10)%100;
 392   6                                                                      break;
 393   6                                                              case 1:
 394   6                                                                      errTolrE2=(++errTolrE2)%100;
 395   6                                                                      break;
 396   6                                                      }
 397   5                                                      break;
 398   5                                              case LONG_PRESS:
 399   5                                                      switch(curDigit){
 400   6                                                              case 0:
 401   6                                                                      errTolrE2%=10;
 402   6                                                                      break;
 403   6                                                              case 1:
 404   6                                                                      errTolrE2-=errTolrE2%10;
 405   6                                                                      break;
 406   6                                                      }
 407   5                                                      break;
 408   5                                      }
 409   4                                      LCDPrintNumFixdgt(0,0,errTolrE2,2);
 410   4                              }
 411   3                              else if(key2Events){
 412   4                                      LCDPrintChar(curDigit,1,0x20);
 413   4                                      switch(key2Events){
 414   5                                              case SHORT_PRESS:
 415   5                                                      curDigit=(++curDigit)%2;
 416   5                                                      break;
 417   5                                              case LONG_PRESS:
 418   5                                                      curDigit=0;
 419   5                                                      break;
 420   5                                      }
 421   4                                      LCDPrintChar(curDigit,1,'^');
 422   4                              }
 423   3                              else{
C51 COMPILER V9.01   MENU                                                                  07/21/2018 21:48:23 PAGE 8   

 424   4                                      switch(key3Events){
 425   5                                              case SHORT_PRESS:
 426   5                                                      isBreak=1;
 427   5                                                      break;
 428   5                                              default:
 429   5                                                      break;
 430   5                                      }
 431   4                              }
 432   3                              RstKeyEvents();
 433   3                      }
 434   2              }
 435   1              switch(rUnit){
 436   2                      case 0x20:
 437   2                              sieveRVal=rNumPart;
 438   2                              break;
 439   2                      case 'K':
 440   2                              sieveRVal=rNumPart*1e3;
 441   2                              break;
 442   2                      case 'M':
 443   2                              sieveRVal=rNumPart*1e6;
 444   2                              break;
 445   2              }
 446   1              errTolr=(float) errTolrE2/100.0;
 447   1              //LCDPrintLine(0,0,"SieveR:");
 448   1              LCDPrintFloat(8,0,sieveRVal);
 449   1              //LCDPrintLine(0,1,"ErrTolr:");
 450   1              LCDPrintFloat(8,1,errTolr);
 451   1              delaynms(3000);
 452   1      }
 453          
 454          
 455          
 456          
 457          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1382    ----
   CONSTANT SIZE    =    190    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     22       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
