C51 COMPILER V9.01   MENU                                                                  07/22/2018 12:06:15 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MENU
OBJECT MODULE PLACED IN .\Menu.obj
COMPILER INVOKED BY: D:\Kell\C51\BIN\C51.EXE ..\Src\Menu.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Menu.lst) OBJECT(.\Menu.obj
                    -)

line level    source

   1          #include "RM.h"
   2          #include "Menu.h"
   3          #include "Timer.h"
   4          #include "Key.h"
   5          #include "LCD1602.h"
   6          #include "CalcR.h"
   7          
   8          #define MENUID_DEBUG_MODE_ON    0                                       //ËèúÂçïÈÄâÈ°πIDÁöÑÂÆèÂÆö‰πâ
   9          #define MENUID_SIEVE_MODE_ON    1
  10          #define MENUID_SET_SIEVE        3
  11          #define MENUID_START_PLOT       4
  12          #define MENUID_RESET_DEVICE     5
  13          #define MENUID_EXIT             6
  14          #define MENUID_DEBUG_YES                7
  15          #define MENUID_DEBUG_NO                 8
  16          #define MENUID_SIEVE_YES        9               
  17          #define MENUID_SIEVE_NO                 10      
  18          #define MENUID_AVERGE_YES       11
  19          #define MENUID_AVERGE_NO                12
  20          #define MENUID_AVERG_MODE_ON    13      
  21          
  22          #define MENU_OPTION_NUM_MAIN    7                                       //ËèúÂçïÊù°ÁõÆÊï∞ÁöÑÂÆèÂÆö‰πâ
  23          #define MENU_OPTION_NUM_YN              2
  24          
  25          typedef struct MenuRecord *ptrToMenuRecord;                     //ÂÆö‰πâÊåáÂêëËèúÂçïËÆ∞ÂΩïÁöÑÊåáÈíà
  26          typedef ptrToMenuRecord   Menu;                                         //ÊåáÂêëËèúÂçïËÆ∞ÂΩïÁöÑÊåáÈíàÁõ¥Êé•Âè´Menu
  27          typedef struct MenuOp     *ptrToMenuOp;                         //ÊåáÂêëËèúÂçïÈÄâÈ°πÁöÑÊåáÈíà
  28          
  29          struct MenuOp{                                                                          //ËèúÂçïÈÄâÈ°πÁöÑÁªìÊûÑ
  30                  uchar opID;                                                                             //ÈÄâÈ°πÁöÑID
  31                  char *opString;                                                                 //ÈÄâÈ°πÊòæÁ§∫ÁöÑÂ≠óÁ¨¶‰∏≤
  32                  Menu subMenu;                                                                   //ÈÄâÈ°πÁöÑÂ≠êËèúÂçï
  33                  void (*pOpFunc) (void);                                                 //ÈÄâÊã©ËØ•ÈÄâÈ°πÊâßË°åÁöÑÂáΩÊï∞
  34          };
  35          
  36          struct MenuRecord{                                                                      //ËèúÂçïËÆ∞ÂΩïÁöÑÁªìÊûÑ
  37                  uchar opNum;                                                                    //ËØ•ËèúÂçïÈÄâÈ°πÁöÑÊù°ÁõÆÊï∞
  38                  Menu superMenu;                                                                 //ËØ•ËèúÂçïÁöÑ‰∏ä‰∏ÄÁ∫ßËèúÂçï
  39                  ptrToMenuOp OpArray;                                                    //ËØ•ËèúÂçïÁöÑÊù°ÁõÆÊï∞ÁªÑ
  40          };
  41          
  42          static code struct MenuOp debugYNOpArray[MENU_OPTION_NUM_YN]={                                                          //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  43                  {MENUID_DEBUG_YES,"Yes",NULL,MenuOpYN},
  44                  {MENUID_DEBUG_NO,"No",NULL,MenuOpYN}
  45          };
  46          static struct MenuRecord debugYNMenuRecord={MENU_OPTION_NUM_YN,NULL,debugYNOpArray};            //Yes No  ËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  47          static code Menu debugYNMenu=&debugYNMenuRecord;                                                                                        //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  48          
  49          static code struct MenuOp sieveYNOpArray[MENU_OPTION_NUM_YN]={                                                          //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  50                  {MENUID_SIEVE_YES,"Yes",NULL,MenuOpYN},
  51                  {MENUID_SIEVE_NO,"No",NULL,MenuOpYN}
  52          };
  53          static struct MenuRecord sieveYNMenuRecord={MENU_OPTION_NUM_YN,NULL,sieveYNOpArray};            //Yes No  ËèúÂçïÁöÑË
C51 COMPILER V9.01   MENU                                                                  07/22/2018 12:06:15 PAGE 2   

             -èúÂçïËÆ∞ÂΩï
  54          static code Menu sieveYNMenu=&sieveYNMenuRecord;                                                                                        //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  55          
  56          static code struct MenuOp avergYNOpArray[MENU_OPTION_NUM_YN]={                                                          //Yes No ËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ
  57                  {MENUID_AVERGE_YES,"Yes",NULL,MenuOpYN},
  58                  {MENUID_AVERGE_NO,"No",NULL,MenuOpYN}
  59          };
  60          static struct MenuRecord avergYNMenuRecord={MENU_OPTION_NUM_YN,NULL,avergYNOpArray};            //Yes No  ËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  61          static code Menu avergYNMenu=&avergYNMenuRecord;                                                                                        //Áî®Âè´ÂÅöynMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  62          
  63          static code struct MenuOp MainMenuOpArray[MENU_OPTION_NUM_MAIN]={                                                       //mainËèúÂçïÁöÑÈÄâÈ°πÊï∞ÁªÑ                             
  64                  {MENUID_DEBUG_MODE_ON,"Debug Mode On",&debugYNMenuRecord,NULL},
  65                  {MENUID_AVERG_MODE_ON,"Averg Mode On",&avergYNMenuRecord,NULL},
  66                  {MENUID_SIEVE_MODE_ON,"Sieve Mode On",&sieveYNMenuRecord,NULL},
  67                  {MENUID_SET_SIEVE,"Set Sieve",NULL,MenuOpSetSieve},
  68                  {MENUID_START_PLOT,"Start Plot",NULL,MenuOpStartPlot},
  69                  {MENUID_RESET_DEVICE,"Reset Device",NULL,MenuOpRstDev},
  70                  {MENUID_EXIT,"Exit",NULL,MenuOpExit}
  71          };
  72          static code struct MenuRecord mainMenuRecord={MENU_OPTION_NUM_MAIN,NULL,MainMenuOpArray};       //mainËèúÂçïÁöÑË
             -èúÂçïËÆ∞ÂΩï
  73          static code Menu mainMenu=&mainMenuRecord;                                                                                                  //Áî®Âè´ÂÅömainMenuÁöÑÊåáÈíàÊåáÂêëËÆ∞ÂΩï
  74          
  75          static Menu  curMenu;                                                           //ÊåáÂêëÂΩìÂâçËèúÂçïÁöÑËÆ∞ÂΩï
  76          static char curOp;                                                                      //ÂΩìÂâçÊù°ÁõÆ
  77          
  78          static bit isExit;                                                                      //Ê∂àÊÅØÂèòÈáèÔºöÊòØÂê¶ÈÄÄÂá∫ËèúÂçï
  79          
  80          extern bit   isSieveOn;                                                         //Ê∂àÊÅØÂèòÈáè:Á≠õÈÄâÊòØÂê¶ÊâìÂºÄ
  81          extern float sieveRVal;                                                         //Á≠õÈÄâÁîµÈòªÁöÑ‰∏≠ÂøÉÂÄº
  82          extern float errTolr;                                                           //ËØØÂ∑ÆÈôê
  83          extern bit   isDebug;                                                           //Ê∂àÊÅØÂèòÈáè:Ë∞ÉËØïÊ®°ÂºèÊâìÂºÄ
  84          extern bit   isAverg;
  85          
  86          sbit    Led1 = P1^0;                                                            //LedÂèòÈáè
  87          sbit    Led2 = P1^1;
  88          sbit    Led3 = P1^2;
  89          
  90          sbit servoConOut = P3^7;
  91          
  92          static uchar pwmTCount;                         
  93          static uchar pwmNCount;                         
  94          static xdata float pwmRVal[17];         
  95          
  96          extern float idata curRValue;
  97          extern code char *mearsStr;
  98          
  99          extern uchar t1IntrTimes;               
 100          extern bit isKeyEvents;
 101          extern bit isTimerEvent;
 102          
 103          extern uchar key1Events;
 104          extern uchar key2Events;
 105          extern uchar key3Events;
 106          
 107          static uint  rNumPart;                                                          //Á≠õÈÄâÁîµÈòªÁöÑ‰∏â‰ΩçÊï∞Â≠óÈÉ®ÂàÜ
 108          static uchar rUnit;                                                                     //Á≠õÈÄâÁîµÈòªÁöÑÂçï‰ΩçÔºåÂèØ‰ª•ÊòØ 0x20 'K' 'M'
 109          static uchar errTolrE2;                                                         //ËØØÂ∑ÆÈôê*100
 110          /**
 111           * ÂàùÂßãÂåñËèúÂçï
 112           * @Author   Xiaobo     Yang
C51 COMPILER V9.01   MENU                                                                  07/22/2018 12:06:15 PAGE 3   

 113           * @DateTime 2018-07-21
 114           * @Summury
 115           */
 116          void InitialMenu(){
 117   1              debugYNMenu->superMenu=mainMenu;                                //ËèúÂçïÂâçÂêé‰∫íÊåáÔºåÂõ†Ê≠§‰∏ÄÈÉ®ÂàÜÊåáÂêëÂ∑•‰ΩúË¶ÅÂà∞Á®ãÂ∫èÂÆåÊàê
 118   1              sieveYNMenu->superMenu=mainMenu;
 119   1              avergYNMenu->superMenu=mainMenu;
 120   1              curMenu=mainMenu;                                                               //ÂàùÂßãÂåñÊâÄÊúâÊúâÂÖ≥ÂÖ®Â±ÄÂèòÈáè
 121   1              curOp=0;
 122   1              isExit=0;
 123   1              isSieveOn=0;
 124   1              sieveRVal=0.0;
 125   1              errTolr=0.0;
 126   1              rNumPart=0;
 127   1              rUnit=0x20;
 128   1              errTolrE2=0;
 129   1              isDebug=1;
 130   1              pwmTCount=0;
 131   1              pwmNCount=0;
 132   1      }
 133          /**
 134           * ÊâìÂºÄËèúÂçï
 135           * @Author   Xiaobo     Yang
 136           * @DateTime 2018-07-21
 137           * @Summury
 138           */
 139          void MenuImpl(){
 140   1              curMenu=mainMenu;                                                               //‰ªéÂ§¥ÂºÄÂßãÊòæÁ§∫ËèúÂçï
 141   1              curOp=0;
 142   1              isExit=0;
 143   1              ShowMenu();
 144   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);                              //ÂºÄÂßãÈîÆÁõòÊâ´Êèè
 145   1              StartTimer();
 146   1              while(!isExit){
 147   2                      if(isKeyEvents){
 148   3                              SwitchTimerFun(TIMERFUN_HALT);                  //TODO:ÊàñËÆ∏ÂèØ‰ª•‰ºòÂåñÊéâ
 149   3                              MenuKeyTreat();
 150   3                              SwitchTimerFun(TIMERFUN_KEY_SCAN);              //ÈáçÂêØÈîÆÁõòÊâ´Êèè
 151   3                              StartTimer();
 152   3                      }
 153   2              }
 154   1      }
 155          /**
 156           * ÊòæÁ§∫ËèúÂçï
 157           * @Author   Xiaobo     Yang
 158           * @DateTime 2018-07-21
 159           * @Summury
 160           */
 161          void ShowMenu(){
 162   1              LCDCls();
 163   1              if(curOp!=0){
 164   2                      LCDMoveCursor(1,0);                                                                             //Ê≠§Â§ÑÊúâËé´ÂêçÂÖ∂Â¶ôÁöÑbugÔºåÈúÄË¶Å‰∏ìÈó®ÈáçËÆæÂÖâÊ†á
 165   2                      LCDPrintStr(1,0,curMenu->OpArray[curOp-1].opString);
 166   2                      LCDPrintStr(1,1,curMenu->OpArray[curOp].opString);
 167   2                      LCDPrintChar(0,1,'>');
 168   2              }
 169   1              else{
 170   2                      LCDMoveCursor(1,0);
 171   2                      LCDPrintStr(1,0,curMenu->OpArray[curOp].opString);
 172   2                      LCDPrintStr(1,1,curMenu->OpArray[curOp+1].opString);
 173   2                      LCDPrintChar(0,0,'>');
 174   2              }
C51 COMPILER V9.01   MENU                                                                  07/22/2018 12:06:15 PAGE 4   

 175   1      }
 176          /**
 177           * Â§ÑÁêÜËèúÂçïÊ®°Âºè‰∏ãÁöÑÊåâÈîÆ‰ø°ÊÅØ
 178           * @Author   Xiaobo     Yang
 179           * @DateTime 2018-07-21
 180           * @Summury
 181           */
 182          void MenuKeyTreat(){
 183   1              if(key1Events){                                                                                 //key1‰ºòÂÖàÁ∫ß>key2‰ºòÂÖàÁ∫ß>key3‰ºòÂÖàÁ∫ß
 184   2                      switch(key1Events){
 185   3                              case SHORT_PRESS:
 186   3                                      curOp=(++curOp)%(curMenu->opNum);                       //Âêë‰∏ãÈÄâÊã©
 187   3                                      ShowMenu();
 188   3                                      break;
 189   3                              case LONG_PRESS:
 190   3                                      curOp=curMenu->opNum-1;
 191   3                                      ShowMenu();
 192   3                                      break;
 193   3                      }
 194   2              }
 195   1              else if(key2Events){
 196   2                      switch(key2Events){
 197   3                              case SHORT_PRESS:                                                               //Âêë‰∏äÈÄâÊã©
 198   3                                      curOp=((--curOp)<0?curOp+(curMenu->opNum):curOp);       
 199   3                                      ShowMenu();
 200   3                                      break;
 201   3                              case LONG_PRESS:
 202   3                                      curOp=0;
 203   3                                      ShowMenu();
 204   3                                      break;
 205   3                      }
 206   2              }
 207   1              else{
 208   2                      switch(key3Events){
 209   3                              case SHORT_PRESS:
 210   3                              if(curMenu->OpArray[curOp].subMenu!=NULL){
 211   4                                      curMenu=curMenu->OpArray[curOp].subMenu;        //ËøõÂÖ•Â≠êËèúÂçï
 212   4                                      curOp=0;
 213   4                                      ShowMenu();
 214   4                              }
 215   3                              else{
 216   4                                      KeyInitial();                                                           //ÂàùÂßãÂåñÂ§ñËÆæÔºåÊó∂ÈíüÂ∑≤ÁªèÂú®MenuImpl‰∏≠ÂÅúÊ≠¢
 217   4                                      isExit=1;                                                                       //ËÆæÂÆöÈÄÄÂá∫Ê®°Âºè
 218   4                                      (*(curMenu->OpArray[curOp].pOpFunc)) ();        //ÊâßË°åÈÄâÈ°πÁöÑÂáΩÊï∞
 219   4                              }       
 220   3                                      break;
 221   3                              case LONG_PRESS:                                                                //ÈïøÊåâÂèØ‰ª•ÂõûÂà∞‰∏äÁ∫ßËèúÂçï
 222   3                                      if(curMenu->superMenu!=NULL){
 223   4                                              curMenu=curMenu->superMenu;
 224   4                                              curOp=0;
 225   4                                              ShowMenu();
 226   4                                      }
 227   3                                      break;
 228   3                              default:
 229   3                                      break;
 230   3                      }
 231   2              }
 232   1              RstKeyEvents();
 233   1      }
 234          /**
 235           * ‰ªÄ‰πàÈÉΩ‰∏çÂÅö
 236           * @Author   Xiaobo     Yang
C51 COMPILER V9.01   MENU                                                                  07/22/2018 12:06:15 PAGE 5   

 237           * @DateTime 2018-07-21
 238           * @Summury
 239           */
 240          void MenuOpExit(){
 241   1              return;
 242   1      }
 243          /**
 244           * Âà©Áî®IAP_CONTRËøõË°åËΩØ‰ª∂Â§ç‰Ωç
 245           * @Author   Xiaobo     Yang
 246           * @DateTime 2018-07-21
 247           * @Summury
 248           */
 249          void MenuOpRstDev(){
 250   1              uint i=3000;
 251   1              Led3=Led2=Led1=0;                                                                               //ÁÅ≠ÁÅØÔºåÁ≠âÂæÖÊøÄÂä®‰∫∫ÂøÉÁöÑ‰∏ÄÂàª
 252   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);
 253   1              StartTimer();
 254   1              while(i){
 255   2                      if(isTimerEvent){
 256   3                              isTimerEvent=0;
 257   3                              i--;                                                                                    //ÊØè0.5msËÆ©iÂáè‰∏ÄÔºå0.5S‰∫Æ‰∏Ä‰∏™ÁÅØ
 258   3                              if(i==2000){
 259   4                                      Led3=1;
 260   4                              }
 261   3                              else if(i==1000){
 262   4                                      Led2=1;
 263   4                              }
 264   3                      }
 265   2                      if(isKeyEvents){                                                                        //Â¶ÇÊúâÈîÆÁõò‰∫ã‰ª∂ÔºåÁ´ãÂç≥‰∏≠Êñ≠ÂáΩÊï∞ÊâßË°å
 266   3                              Led3=Led2=0;
 267   3                              return;
 268   3                      }
 269   2              }
 270   1              Led1=1;
 271   1              delaynms(500);
 272   1              ISP_CONTR=0x60;                                                                                 //ËΩØ‰ª∂Â§ç‰Ωç
 273   1      }
 274          /**
 275           * YNËèúÂçïÊâßË°åÔºåÁî®‰∫éÊîπÂèòdebugÂíåsieveÊ®°Âºè
 276           * @Author   Xiaobo     Yang
 277           * @DateTime 2018-07-21
 278           * @Summury
 279           */
 280          void MenuOpYN(){
 281   1              switch(curMenu->OpArray[curOp].opID){
 282   2                      case MENUID_DEBUG_YES:
 283   2                              isDebug=1;
 284   2                              break;
 285   2                      case MENUID_DEBUG_NO:
 286   2                              isDebug=0;
 287   2                              break;
 288   2                      case MENUID_SIEVE_YES:
 289   2                              isSieveOn=1;
 290   2                              break;
 291   2                      case MENUID_SIEVE_NO:
 292   2                              isSieveOn=0;
 293   2                              break;
 294   2                      case MENUID_AVERGE_YES:
 295   2                              isAverg=1;
 296   2                              break;
 297   2                      case MENUID_AVERGE_NO:
 298   2                              isAverg=0;
C51 COMPILER V9.01   MENU                                                                  07/22/2018 12:06:15 PAGE 6   

 299   2                              break;
 300   2              }
 301   1      }
 302          /**
 303           * ËΩ¨Âä®ËàµÊú∫ÁîªÊõ≤Á∫ø
 304           * @Author   Xiaobo     Yang
 305           * @DateTime 2018-07-21
 306           * @Summury
 307           */
 308          void MenuOpStartPlot(){
 309   1              uchar curShow;
 310   1              uchar isBreak;
 311   1              LCDCls();
 312   1              LCDPrintLine(0,0,mearsStr);
 313   1              pwmTCount=0;
 314   1              pwmNCount=0;
 315   1              SwitchTimerFun(TIMERFUN_PWM);
 316   1              StartTimer();
 317   1              while(1){
 318   2                      if(isTimerEvent){
 319   3                              if(pwmTCount==17){                                      
 320   4                                      break;
 321   4                              }
 322   3      
 323   3                              if(t1IntrTimes==201){                           
 324   4                                      ++pwmNCount;                                    
 325   4                                      t1IntrTimes=1;
 326   4                              }
 327   3                              if(t1IntrTimes<=7+pwmTCount)
 328   3                                      servoConOut=1;                                  
 329   3                              else
 330   3                                      servoConOut=0;
 331   3      
 332   3                              if(pwmNCount==20){                                      
 333   4                                      pwmNCount=0;
 334   4                                      SwitchTimerFun(TIMERFUN_FREQ_MEASRURE); 
 335   4                                      StartTimer();
 336   4                                      while(!isTimerEvent);
 337   4                                      GetRVal();                                              
 338   4                                      pwmRVal[pwmTCount++]=curRValue; 
 339   4                                      SwitchTimerFun(TIMERFUN_PWM);   
 340   4                                      StartTimer();                                   
 341   4                              }
 342   3                      }
 343   2              }
 344   1              curShow=0;
 345   1              isBreak=0;
 346   1              LCDCls();
 347   1              LCDPrintFloat(0,0,pwmRVal[curShow]);
 348   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);
 349   1              StartTimer();
 350   1              while(!isBreak){
 351   2                      if(isKeyEvents){
 352   3                              if(key1Events){
 353   4                                      switch(key1Events){
 354   5                                              case SHORT_PRESS:
 355   5                                                      curShow=(++curShow)%17;
 356   5                                                      break;
 357   5                                              case LONG_PRESS:
 358   5                                                      curShow=16;
 359   5                                                      break;
 360   5                                      }
C51 COMPILER V9.01   MENU                                                                  07/22/2018 12:06:15 PAGE 7   

 361   4                              }
 362   3                              else if(key2Events){
 363   4                                      switch(key2Events){
 364   5                                              case SHORT_PRESS:
 365   5                                                      curShow= (--curShow)<0?16:curShow;
 366   5                                                      break;
 367   5                                              case LONG_PRESS:
 368   5                                                      curShow=0;
 369   5                                                      break;
 370   5                                      }
 371   4                              }
 372   3                              else{
 373   4                                      switch(key3Events){
 374   5                                              case SHORT_PRESS:
 375   5                                                      isBreak=1;
 376   5                                                      break;
 377   5                                              default:
 378   5                                                      break;
 379   5                                      }
 380   4                              }
 381   3                              LCDPrintFloat(0,0,pwmRVal[curShow]);
 382   3                              RstKeyEvents();
 383   3                      }
 384   2              }
 385   1      }
 386          /**
 387           * ËÆæÁΩÆÁ≠õÈÄâÊù°‰ª∂
 388           * @Author   Xiaobo     Yang
 389           * @DateTime 2018-07-21
 390           * @Summury
 391           */
 392          void MenuOpSetSieve (){
 393   1              uchar curDigit=0;
 394   1              uchar isBreak=0;
 395   1              LCDCls();
 396   1              LCDPrintNumFixdgt(0,0,rNumPart,3);
 397   1              LCDPrintChar(3,0,rUnit);
 398   1              LCDPrintChar(curDigit,1,'^');
 399   1              SwitchTimerFun(TIMERFUN_KEY_SCAN);
 400   1              StartTimer();
 401   1              while(!isBreak){
 402   2                      if(isKeyEvents){
 403   3                              if(key1Events){
 404   4                                      switch(key1Events){
 405   5                                              case SHORT_PRESS:
 406   5                                                      switch(curDigit){
 407   6                                                              case 0:
 408   6                                                                      rNumPart=(rNumPart+100)%1000;
 409   6                                                                      break;
 410   6                                                              case 1:
 411   6                                                                      rNumPart=(rNumPart+10)%1000;
 412   6                                                                      break;
 413   6                                                              case 2:
 414   6                                                                      rNumPart=(rNumPart+1)%1000;
 415   6                                                                      break;
 416   6                                                              case 3:
 417   6                                                                      switch(rUnit){
 418   7                                                                              case 0x20:
 419   7                                                                                      rUnit='K';
 420   7                                                                                      break;
 421   7                                                                              case 'K':
 422   7                                                                                      rUnit='M';
C51 COMPILER V9.01   MENU                                                                  07/22/2018 12:06:15 PAGE 8   

 423   7                                                                                      break;
 424   7                                                                              case 'M':
 425   7                                                                                      rUnit=0x20;
 426   7                                                                                      break;
 427   7                                                                      }
 428   6                                                              break;
 429   6                                                      }
 430   5                                                      break;
 431   5                                              case LONG_PRESS:
 432   5                                                      switch(curDigit){
 433   6                                                              case 0:
 434   6                                                                      rNumPart%=100;
 435   6                                                                      break;
 436   6                                                              case 1:
 437   6                                                                      rNumPart-=((rNumPart%100)/10)*10;
 438   6                                                                      break;
 439   6                                                              case 2:
 440   6                                                                      rNumPart-=rNumPart%10;
 441   6                                                                      break;
 442   6                                                              case 3:
 443   6                                                                      rUnit=0x20;
 444   6                                                                      break;
 445   6                                                      }
 446   5                                                      break;
 447   5                                      }
 448   4                                      LCDPrintNumFixdgt(0,0,rNumPart,3);
 449   4                                      LCDPrintChar(3,0,rUnit);
 450   4                              }
 451   3                              else if(key2Events){
 452   4                                      LCDPrintChar(curDigit,1,0x20);
 453   4                                      switch(key2Events){
 454   5                                              case SHORT_PRESS:
 455   5                                                      curDigit=++curDigit%4;
 456   5                                                      break;
 457   5                                              case LONG_PRESS:
 458   5                                                      if(curDigit==3){
 459   6                                                              curDigit=0;
 460   6                                                      }
 461   5                                                      else{
 462   6                                                              curDigit=3;
 463   6                                                      }
 464   5                                                      break;
 465   5                                      }
 466   4                                      LCDPrintChar(curDigit,1,'^');
 467   4                              }
 468   3                              else{
 469   4                                      switch(key3Events){
 470   5                                              case SHORT_PRESS:
 471   5                                                      isBreak=1;
 472   5                                                      break;
 473   5                                              default:
 474   5                                                      break;
 475   5                                      }
 476   4                              }
 477   3                              RstKeyEvents(); 
 478   3                      }
 479   2              }
 480   1              curDigit=0;
 481   1              isBreak=0;
 482   1              LCDCls();
 483   1              LCDPrintNumFixdgt(0,0,errTolrE2,2);
 484   1              LCDPrintChar(2,0,'%');
C51 COMPILER V9.01   MENU                                                                  07/22/2018 12:06:15 PAGE 9   

 485   1              LCDPrintChar(curDigit,1,'^');
 486   1              while(!isBreak){
 487   2                      if(isKeyEvents){
 488   3                              if(key1Events){
 489   4                                      switch(key1Events){
 490   5                                              case SHORT_PRESS:
 491   5                                                      switch(curDigit){
 492   6                                                              case 0:
 493   6                                                                      errTolrE2=(errTolrE2+10)%100;
 494   6                                                                      break;
 495   6                                                              case 1:
 496   6                                                                      errTolrE2=(++errTolrE2)%100;
 497   6                                                                      break;
 498   6                                                      }
 499   5                                                      break;
 500   5                                              case LONG_PRESS:
 501   5                                                      switch(curDigit){
 502   6                                                              case 0:
 503   6                                                                      errTolrE2%=10;
 504   6                                                                      break;
 505   6                                                              case 1:
 506   6                                                                      errTolrE2-=errTolrE2%10;
 507   6                                                                      break;
 508   6                                                      }
 509   5                                                      break;
 510   5                                      }
 511   4                                      LCDPrintNumFixdgt(0,0,errTolrE2,2);
 512   4                              }
 513   3                              else if(key2Events){
 514   4                                      LCDPrintChar(curDigit,1,0x20);
 515   4                                      switch(key2Events){
 516   5                                              case SHORT_PRESS:
 517   5                                                      curDigit=(++curDigit)%2;
 518   5                                                      break;
 519   5                                              case LONG_PRESS:
 520   5                                                      curDigit=0;
 521   5                                                      break;
 522   5                                      }
 523   4                                      LCDPrintChar(curDigit,1,'^');
 524   4                              }
 525   3                              else{
 526   4                                      switch(key3Events){
 527   5                                              case SHORT_PRESS:
 528   5                                                      isBreak=1;
 529   5                                                      break;
 530   5                                              default:
 531   5                                                      break;
 532   5                                      }
 533   4                              }
 534   3                              RstKeyEvents();
 535   3                      }
 536   2              }
 537   1              switch(rUnit){
 538   2                      case 0x20:
 539   2                              sieveRVal=rNumPart;
 540   2                              break;
 541   2                      case 'K':
 542   2                              sieveRVal=rNumPart*1e3;
 543   2                              break;
 544   2                      case 'M':
 545   2                              sieveRVal=rNumPart*1e6;
 546   2                              break;
C51 COMPILER V9.01   MENU                                                                  07/22/2018 12:06:15 PAGE 10  

 547   2              }
 548   1              errTolr=(float) errTolrE2/100.0;
 549   1              LCDCls();
 550   1              LCDPrintNumFixdgt(0,0,rNumPart,3);
 551   1              LCDPrintChar(3,0,rUnit);
 552   1              LCDPrintNumFixdgt(0,1,errTolrE2,2);
 553   1              LCDPrintFloat(8,0,sieveRVal);
 554   1              LCDPrintFloat(8,1,errTolr);
 555   1              delaynms(3000);
 556   1      }
 557          
 558          
 559          
 560          
 561          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1917    ----
   CONSTANT SIZE    =    237    ----
   XDATA SIZE       =     68    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     31       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
