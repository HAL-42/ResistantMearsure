C51 COMPILER V9.01   KEY                                                                   07/22/2018 14:13:38 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\Key.obj
COMPILER INVOKED BY: D:\Kell\C51\BIN\C51.EXE ..\Src\Key.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Key.lst) OBJECT(.\Key.obj)

line level    source

   1          #include "RM.h"
   2          #include "Key.h"
   3          #include "Timer.h"
   4          
   5          #define KEY_STATE_UNPRESSED     0x00            //æŒ‰é”®çŠ¶æ€ï¼šæ²¡æœ‰æŒ‰ä¸‹
   6          #define KEY_STATE_DEBOUNCE      0x01            //æŒ‰é”®çŠ¶æ€ï¼šæŒ‰ä¸‹ï¼Œä½†æŒ‰ä¸‹æ—¶é—´ä¸è¶³ï¼Œå¯èƒ½è¿˜åœ¨é¢¤åŠ¨ï¼Œå›
             - æ­¤ç°åœ¨æ¬¡çŠ¶æ€ç­‰å€™ä¸€æ®µæ—¶é—´
   7          #define KEY_STATE_PRESSED   0x02                //æŒ‰é”®çŠ¶æ€ï¼šç¡®å®šæŒ‰é”®æŒ‰ä¸‹å¹¶ç¨³å®šï¼Œåœ¨æ­¤çŠ¶æ€ä¸‹åŒºåˆ†çŸ­æ
             -Œ‰å’Œé•¿æŒ‰
   8          #define KEY_STATE_WAITLOOSE 0x03                //æŒ‰é”®çŠ¶æ€ï¼šç­‰å¾…é•¿æŒ‰åæ¾åä¼šåˆ°æ²¡æœ‰æŒ‰ä¸‹çŠ¶æ€
   9          
  10          //////////////////////////////////////////////////////////////////////////////////////////////////
  11          //TODO:æ—¶é•¿è¿˜æœ‰å¾…è°ƒè¯•ç¡®å®šï¼Œå¦‚æœæœ‰éœ€è¦DEBOUNCE_TIMEç½®ä¸º0ï¼ŒLONG_PRESS_TIMEç½®ä¸ºæ— ç©·ï¼Œå
             -–æ¶ˆæ¶ˆé¢¤å’Œé•¿æŒ‰åŠŸèƒ½ //
  12          /////////////////////////////////////////////////////////////////////////////////////////////////
  13          #define DEBOUNCE_TIME_FREQ                      50                              //50æ¬¡KeyScanå®Œæˆæ¶ˆé¢¤(åŸºäºè®¤ä¸ºä¸¤æ¬¡KeyScanç›¸è·50ä¸ªæœºå™¨å
             -‘¨æœŸï¼Œè°ƒæ•´ï¼)
  14          #define LONG_PRESS_TIME_FREQ            60000                   //60000æ¬¡KeyScanåˆ¤å®šä¸ºé•¿æŒ‰
  15          #define DEBOUNCE_TIME_KEYSCAN           1                               //2msæ¶ˆé¢¤
  16          #define LONG_PRESS_TIME_KEYSCAN         2000                    //2såˆ¤å®šä¸ºé•¿æŒ‰
  17          
  18          
  19          sbit key1=P1^5;                                                                 //å¤–éƒ¨å…¨å±€å˜é‡ï¼Œè§main.c
  20          sbit key2=P1^4;
  21          sbit key3=P1^3;
  22          
  23          extern uchar timerFun;                                                          //å¤–éƒ¨å…¨å±€å˜é‡ï¼Œè§main.c
  24          
  25          extern uchar key1Events;                                                        //å¤–éƒ¨å…¨å±€å˜é‡ï¼Œè§main.c
  26          extern uchar key2Events;
  27          extern uchar key3Events;
  28          
  29          extern bit isKeyEvents;                                                         //å¤–éƒ¨å…¨å±€å˜é‡ï¼Œè§main.c
  30          
  31          static uchar key1State;                                                         //è®°å½•å„ä¸ªæŒ‰é”®çŠ¶æ€
  32          static uchar key2State;
  33          static uchar key3State;
  34          
  35          static uint key1Timer;                                                          //å„ä¸ªæŒ‰é”®çš„è®¡æ—¶å™¨ï¼Œç”¨åœ¨æ¶ˆé¢¤å’Œé•¿æŒ‰åˆ¤æ–­ä¸Š
  36          static uint key2Timer;  
  37          static uint key3Timer;
  38          
  39          static uint debounceTime;
  40          static uint longPressTime;
  41          /**
  42           * é€ä¸ªæ‰«ææŒ‰é”®ï¼Œå¹¶æŠŠæŒ‰é”®æ‰«æç»“æœï¼ˆæ— åŠ¨ä½œï¼Œé•¿æŒ‰ï¼ŒçŸ­æŒ‰ï¼‰æ”¾åˆ°keyxEventså…¨å±€å˜
             -é‡ä¸­ç­‰å¾…å¤„ç†
  43           * @Author   Xiaobo     Yang
  44           * @DateTime 2018-07-16
  45           * @Summury
  46           */
  47          void KeyScan(){
  48   1              if(timerFun==TIMERFUN_KEY_SCAN){
  49   2                      debounceTime=DEBOUNCE_TIME_KEYSCAN;
  50   2                      longPressTime=LONG_PRESS_TIME_KEYSCAN;
C51 COMPILER V9.01   KEY                                                                   07/22/2018 14:13:38 PAGE 2   

  51   2              }
  52   1              else{
  53   2                      debounceTime=DEBOUNCE_TIME_FREQ;
  54   2                      longPressTime=LONG_PRESS_TIME_FREQ;
  55   2              }
  56   1              switch(key1State){                                                                              //é€‰æ‹©çŠ¶æ€                                  
  57   2                      case KEY_STATE_UNPRESSED:                                                       //æ²¡æœ‰æŒ‰ä¸‹çŠ¶æ€    
  58   2                              if(!key1) {                                                                             //æŒ‰é”®æŒ‰ä¸‹ï¼ˆä½ç”µå¹³ï¼‰ï¼Œè½¬ç§»åˆ°æ¶ˆé¢¤çŠ¶æ€
  59   3                                      key1State=KEY_STATE_DEBOUNCE;
  60   3                                      key1Timer=0;                                                            //åˆå§‹åŒ–è®¡æ—¶å™¨
  61   3                              }
  62   2                              break;
  63   2                      case KEY_STATE_DEBOUNCE:                                                        //æ¶ˆé¢¤çŠ¶æ€
  64   2                              if(key1) {                                                                              //æŒ‰é”®æ¾å¼€ï¼Œè¯´æ˜è¿˜åœ¨é¢¤åŠ¨ï¼Œå›åˆ°æ²¡æœ‰æŒ‰ä¸‹çŠ¶æ€
  65   3                                      key1State=KEY_STATE_UNPRESSED;                                  
  66   3                              }
  67   2                              else if(++key1Timer>debounceTime){                              //æŒ‰é”®æŒ‰ä¸‹ï¼Œå°±è®¡æ•°ï¼Œè‹¥æŒ‰ä¸‹æ—¶é•¿è¶³å¤Ÿï¼Œè¯´æ˜æŒ‰é”®
             -ç¨³å®šï¼Œè½¬å…¥æŒ‰ä¸‹çŠ¶æ€
  68   3                                      key1State=KEY_STATE_PRESSED;                            
  69   3                                      key1Timer=0;                                                            //é‡è®¾è®¡æ—¶å™¨
  70   3                              }
  71   2                              break;
  72   2                      case KEY_STATE_PRESSED:
  73   2                              if(key1){                                                                               //å¦‚æœæŒ‰é”®æ¾å¼€ï¼ŒæŒ‰ä¸‹æ—¶é—´åˆä¸å¤Ÿï¼Œå°±ç»™å‡ºçŸ­æŒ‰äº‹ä»¶ï¼Œå¹¶è½¬ç§»åˆ°æ
             -œªæŒ‰ä¸‹çŠ¶æ€
  74   3                                      key1State=KEY_STATE_UNPRESSED;
  75   3                                      key1Events=SHORT_PRESS;
  76   3                                      isKeyEvents=1;                                                          //å‘Šè¯‰ä¸»ç¨‹åºæœ‰æŒ‰é”®äº‹ä»¶å‘ç”Ÿ
  77   3                              }
  78   2                              else if(++key1Timer>longPressTime){                             //å¦‚æœæŒ‰é”®æ²¡æœ‰æ¾å¼€ï¼Œè®¡æ—¶ï¼Œè¶³å¤Ÿé•¿åå‘å‡ºé•¿æŒ‰äº
             -‹ä»¶ï¼Œè½¬ç§»åˆ°ç­‰å¾…æ¾æ‰‹çŠ¶æ€
  79   3                                      key1Events=LONG_PRESS;
  80   3                                      isKeyEvents=1;                                                          //å‘Šè¯‰ä¸»ç¨‹åºæœ‰æŒ‰é”®äº‹ä»¶å‘ç”Ÿ
  81   3                                      key1State=KEY_STATE_WAITLOOSE;
  82   3                              }
  83   2                              break;
  84   2                      case KEY_STATE_WAITLOOSE:
  85   2                              if(key1) key1State=KEY_STATE_UNPRESSED;                 //ä¸€æ—¦æ¾æ‰‹ï¼Œå°±ä¼šåˆ°æœªæŒ‰ä¸‹çŠ¶æ€
  86   2                              break;
  87   2              }
  88   1      
  89   1              switch(key2State){                                                                              //å‚è§key1Stateéƒ¨åˆ†æ³¨é‡Š
  90   2                      case KEY_STATE_UNPRESSED:
  91   2                              if(!key2) {
  92   3                                      key2State=KEY_STATE_DEBOUNCE;
  93   3                                      key2Timer=0;
  94   3                              }
  95   2                              break;
  96   2                      case KEY_STATE_DEBOUNCE:
  97   2                              if(key2) {
  98   3                                      key2State=KEY_STATE_UNPRESSED;
  99   3                              }
 100   2                              else if(++key2Timer>debounceTime){
 101   3                                      key2State=KEY_STATE_PRESSED;
 102   3                                      key2Timer=0;
 103   3                              }
 104   2                              break;
 105   2                      case KEY_STATE_PRESSED:
 106   2                              if(key2){
 107   3                                      key2State=KEY_STATE_UNPRESSED;
 108   3                                      key2Events=SHORT_PRESS;
 109   3                                      isKeyEvents=1;
C51 COMPILER V9.01   KEY                                                                   07/22/2018 14:13:38 PAGE 3   

 110   3                              }
 111   2                              else if(++key2Timer>longPressTime){
 112   3                                      key2Events=LONG_PRESS;
 113   3                                      isKeyEvents=1;
 114   3                                      key2State=KEY_STATE_WAITLOOSE;
 115   3                              }
 116   2                              break;
 117   2                      case KEY_STATE_WAITLOOSE:
 118   2                              if(key2) key2State=KEY_STATE_UNPRESSED;
 119   2                              break;
 120   2              }
 121   1      
 122   1              switch(key3State){                                                                              //å‚è§key1Stateéƒ¨åˆ†æ³¨é‡Š
 123   2                      case KEY_STATE_UNPRESSED:
 124   2                              if(!key3) {
 125   3                                      key3State=KEY_STATE_DEBOUNCE;
 126   3                                      key3Timer=0;
 127   3                              }
 128   2                              break;
 129   2                      case KEY_STATE_DEBOUNCE:
 130   2                              if(key3) {
 131   3                                      key3State=KEY_STATE_UNPRESSED;
 132   3                              }
 133   2                              else if(++key3Timer>debounceTime){
 134   3                                      key3State=KEY_STATE_PRESSED;
 135   3                                      key3Timer=0;
 136   3                              }
 137   2                              break;
 138   2                      case KEY_STATE_PRESSED:
 139   2                              if(key3){
 140   3                                      key3State=KEY_STATE_UNPRESSED;
 141   3                                      key3Events=SHORT_PRESS;
 142   3                                      isKeyEvents=1;
 143   3                              }
 144   2                              else if(++key3Timer>longPressTime){
 145   3                                      key3Events=LONG_PRESS;
 146   3                                      isKeyEvents=1;
 147   3                                      key3State=KEY_STATE_WAITLOOSE;
 148   3                              }
 149   2                              break;
 150   2                      case KEY_STATE_WAITLOOSE:
 151   2                              if(key3) key3State=KEY_STATE_UNPRESSED;
 152   2                              break;
 153   2              }
 154   1      }
 155          /**
 156           * å®ŒæˆæŒ‰é”®ä¿¡å·å¤„ç†åï¼Œåº”è¯¥è°ƒç”¨è¯¥å‡½æ•°åŠæ—¶æ¸…ç†æ‰ä¸Šä¸€æ¬¡æŒ‰é”®æ‰«æå–å¾—çš„äº‹ä»¶
 157           * @Author   Xiaobo     Yang
 158           * @DateTime 2018-07-18
 159           * @Summury æ³¨æ„ï¼Œåœ¨æœ¬ç¨‹åºä¸­ï¼Œåªæœ‰æŒ‰é”®ä¿¡å·è¢«å¤„ç†åï¼Œæ‰ä¼šè¿›è¡Œä¸‹ä¸€æ¬¡KeyScanå¼•å…¥
             -æ–°çš„äº‹ä»¶ã€‚
 160           * è€Œå·²å¤„ç†æŒ‰é”®äº‹ä»¶è¦åŠæ—¶resetæ‰ï¼Œæ‰èƒ½è®©æ¯æ¬¡KeyScanäº’ä¸ç›¸æ‰°ã€‚
 161           */
 162          void RstKeyEvents(){
 163   1              key1Events=NONE_PRESS;
 164   1              key2Events=NONE_PRESS;
 165   1              key3Events=NONE_PRESS;
 166   1              isKeyEvents=NONE_PRESS;
 167   1      }
 168          /**
 169           * åˆå§‹åŒ–æŒ‰é”®çŠ¶æ€ï¼Œç”¨äºè½¯é‡ç½®
 170           * @Author   Xiaobo     Yang
C51 COMPILER V9.01   KEY                                                                   07/22/2018 14:13:38 PAGE 4   

 171           * @DateTime 2018-07-18
 172           * @Summury ç”±äºé‡ç½®æŒ‰é’®è¢«å ç”¨ï¼Œå› æ­¤é‡‡ç”¨è½¯é‡ç½®å‡½æ•°ï¼Œè½¯é‡ç½®æ—¶è¦é‡è®¾æ‰€æœ‰å’Œkeyx
             -æœ‰å…³å˜é‡
 173           */
 174          void KeyInitial(){
 175   1              key1Events=NONE_PRESS;
 176   1              key2Events=NONE_PRESS;
 177   1              key3Events=NONE_PRESS;
 178   1              isKeyEvents=0;
 179   1              key1State=KEY_STATE_UNPRESSED;
 180   1              key2State=KEY_STATE_UNPRESSED;
 181   1              key3State=KEY_STATE_UNPRESSED;
 182   1              key1Timer=0;
 183   1              key2Timer=0;
 184   1              key3Timer=0;
 185   1      }
 186          /**
 187           * æˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºä»€ä¹ˆè¦å†™è¿™ä¸ªå‡½æ•°ï¼Œæ„Ÿè§‰å¾ˆå¥½ç©çš„æ ·å­
 188           */
 189          void WaitKey(void (*key1Fun) (void),void (*key2Fun) (void),void (*key3Fun) (void)){
 190   1              while(!isKeyEvents) KeyScan();
 191   1              if(key1Events) (*key1Fun) ();
 192   1              if(key2Events) (*key2Fun) ();
 193   1              if(key3Events) (*key3Fun) ();
 194   1              RstKeyEvents();
 195   1      }
 196          /**
 197           * æŒ‰ä¸‹ä»»æ„é”®ï¼Œå¦åˆ™é˜»å¡
 198           * @Author   Xiaobo     Yang
 199           * @DateTime 2018-07-19
 200           * @Summury
 201           */
 202          void PressAnyKey(){
 203   1              while(!isKeyEvents) KeyScan();
 204   1              KeyInitial();
 205   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    421    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
